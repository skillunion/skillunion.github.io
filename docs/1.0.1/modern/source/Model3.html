<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-grid-selection-Model'>/**
</span> * A selection model for {@link Ext.grid.Grid grids} which allows you to select data in
 * a spreadsheet-like manner.
 *
 * Supported features:
 *
 *  - Single / Range / Multiple individual row selection
 *  - Single / Range cell selection
 *  - Column selection by click selecting column headers
 *  - Select / deselect all by clicking in the top-left, header
 *  - Adds row number column to enable row selection
 *  - Optionally you can enable row selection using checkboxes
 *
 * # Example usage
 *
 *     @example
 *     Ext.create({
 *         xtype: &#39;grid&#39;,
 *         title: &#39;Simpsons&#39;,
 *         store: [{
 *             name: &#39;Lisa&#39;,
 *             email: &#39;lisa@simpsons.com&#39;,
 *             phone: &#39;555-111-1224&#39;
 *         }, {
 *             name: &#39;Bart&#39;,
 *             email: &#39;bart@simpsons.com&#39;,
 *             phone: &#39;555-222-1234&#39;
 *         }, {
 *             name: &#39;Homer&#39;,
 *             email: &#39;homer@simpsons.com&#39;,
 *             phone: &#39;555-222-1244&#39;
 *         }],
 *         width: 400,
 *         height: 300,
 *         renderTo: Ext.getBody(),
 *         columns: [{
 *             text: &#39;Name&#39;,
 *             dataIndex: &#39;name&#39;
 *         }, {
 *             text: &#39;Email&#39;,
 *             dataIndex: &#39;email&#39;,
 *             flex: 1
 *         }, {
 *             text: &#39;Phone&#39;,
 *             dataIndex: &#39;phone&#39;
 *         }],
 *         selectable: {
 *             columns: false, // Can select cells and rows, but not columns
 *             extensible: true // Uses the draggable selection extender
 *         }
 *     });
 *
 * # Using {@link Ext.data.virtual.Store}s
 * It is very important to remember that a {@link Ext.data.virtual.Store} does *not* contain the
 * full dataset. The purpose of a VirtualStore is to only hold in the client, a range of
 * pages from the dataset that corresponds with what is currently visible in the grid
 * (plus a few pages above and below the visible range to allow fast scrolling).
 *
 * When using &quot;select all&quot; rows and a VirtualStore, an `allSelected` flag is set, and so all
 * records which are read into the client side cache will thenceforth be selected, and will
 * be rendered as selected in the grid.
 *
 * *But records which have not been read into the cache will obviously not be available
 * when interrogating selected records. What is stored as being selected is row index ranges.*
 *
 */
Ext.define(&#39;Ext.grid.selection.Model&#39;, {
    extend: &#39;Ext.dataview.selection.Model&#39;,
    requires: [
        &#39;Ext.grid.Location&#39;,
        &#39;Ext.grid.selection.*&#39;
    ],

    alias: &#39;selmodel.grid&#39;,

<span id='Ext-grid-selection-Model-property-isGridSelectionModel'>    isGridSelectionModel: true,
</span>
    config: {
<span id='Ext-grid-selection-Model-cfg-columns'>        /**
</span>         * @cfg {Boolean} columns
         * Set to `true` to enable selection of columns.
         *
         * **NOTE**: This will disable sorting on header click and instead provide column
         * selection and deselection. Sorting is still available via column header menu.
         */
        columns: {
            $value: false,
            lazy: true
        },

<span id='Ext-grid-selection-Model-cfg-cells'>        /**
</span>         * @cfg {Boolean} cells
         * Set to `true` to enable selection of individual cells or a single rectangular
         * range of cells. This will provide cell range selection using click, and
         * potentially drag to select a rectangular range if (@link #cfg!drag} is `true`.
         * You can also use &quot;SHIFT + arrow&quot; key navigation to select a range of cells.
         */
        cells: {
            $value: false,
            lazy: true
        },

<span id='Ext-grid-selection-Model-cfg-rows'>        /**
</span>         * @cfg {Boolean} rows
         * Set to `true` to enable selection of rows by clicking on the selection model&#39;s
         * {@link #cfg!checkbox} column, {@link Ext.grid.Grid#cfg!rowNumbers row number column}
         * or, if {@link #cfg!drag} is `true`, by swiping down the
         * {@link Ext.grid.Grid#cfg!rowNumbers row number column}.
         */
        rows: {
            $value: true,
            lazy: true
        },

<span id='Ext-grid-selection-Model-cfg-drag'>        /**
</span>         * @cfg {Boolean} drag
         * Set to `true` to enables cell and row range selection by dragging.
         */
        drag: false,

<span id='Ext-grid-selection-Model-cfg-extensible'>        /**
</span>         * @cfg {String} extensible
         * This configures whether this selection model is to implement a mouse based
         * dragging gesture to extend a *contiguous* selection.
         *
         * Note that if there are multiple, discontiguous selected rows or columns,
         * selection extension is not available.
         *
         * If set, then the bottom right corner of the contiguous selection will display a
         * drag handle. By dragging this, an extension area may be defined into which the
         * selection is extended.
         *
         * The {@link Ext.grid.Grid#beforeselectionextend beforeselectionextend} event fires
         * at the end of the drag though the owning grid. Event handlers may manipulate the
         * store data in any way.
         *
         * Possible values for this configuration are
         *
         *    - `&quot;x&quot;` Only allow extending the block to the left or right.
         *    - `&quot;y&quot;` Only allow extending the block above or below.
         *    - `&quot;xy&quot;` Allow extending the block in both dimensions.
         *    - `&quot;both&quot;` Allow extending the block in both dimensions.
         *    - `true` Allow extending the block in both dimensions.
         *    - `false` Disable the extensible feature
         *    - `null` Disable the extensible feature
         *
         * It&#39;s important to notice that setting this to `&quot;both&quot;`, `&quot;xy&quot;` or `true` will
         * allow you to extend the selection in both directions, but only one direction at
         * a time. It will NOT be possible to drag it diagonally.
         */
        extensible: {
            $value: false,
            lazy: true
        },

<span id='Ext-grid-selection-Model-cfg-checkbox'>        /**
</span>         * @cfg {Boolean} checkbox
         * Configure as `true` to include a checkbox to indicate selection of *Records*. The
         * checkbox cell plays no part in cell or column selection apart from being a selected
         * cell and part of any iteration through selections.
         *
         * See {@link #cfg!headerCheckbox} for inclusion of a &quot;select all&quot; checkbox in the
         * column header of the checkbox column.
         *
         * See {@link #cfg!checkboxDefaults} for how to influence the configuration of the
         * checkbox column header.
         */
        checkbox: false,

<span id='Ext-grid-selection-Model-cfg-headerCheckbox'>        /**
</span>         * @cfg {Boolean} headerCheckbox
         * Configure as `false` to not display the header checkbox at the top of the checkbox
         * column when {@link #checkboxSelect} is set.
         */
        headerCheckbox: true,

<span id='Ext-grid-selection-Model-cfg-checkboxDefaults'>        /**
</span>         * @cfg {Object} checkboxDefaults
         * A config object to configure the checkbox column header if {@link #cfg!checkbox}
         * is set.
         */
        checkboxDefaults: {
            xtype: &#39;selectioncolumn&#39;,
            text: null,
            width: 30
        },

<span id='Ext-grid-selection-Model-cfg-showNumbererColumn'>        showNumbererColumn: false
</span>    },

<span id='Ext-grid-selection-Model-event-selectionchange'>    /**
</span>     * @event selectionchange
     * Fired *by the grid* after the selection changes. Return `false` to veto the selection
     * extension.
     *
     * @param {Ext.grid.Panel} grid The grid whose selection has changed.
     * @param {Ext.dataview.selection.Selection} selection A subclass of
     * {@link Ext.dataview.selection.Selection} describing the new selection.
     */

<span id='Ext-grid-selection-Model-cfg-checkboxSelect'>    /**
</span>     * @cfg {Boolean} checkboxSelect
     * Enables selection of the row via clicking on checkbox. Note: this feature will add
     * new column at position specified by {@link #checkboxColumnIndex}.
     */
    checkboxSelect: false,

<span id='Ext-grid-selection-Model-cfg-checkboxColumnIndex'>    /**
</span>     * @cfg {Number/String} checkboxColumnIndex
     * The index at which to insert the checkbox column.
     * Supported values are a numeric index, and the strings &#39;first&#39; and &#39;last&#39;. Only valid
     * when set before render.
     */
    checkboxColumnIndex: 0,

<span id='Ext-grid-selection-Model-cfg-mode'>    mode: &#39;multi&#39;,
</span>
<span id='Ext-grid-selection-Model-property-columnSelectCls'>    columnSelectCls: Ext.baseCSSPrefix + &#39;selmodel-column-select&#39;,
</span><span id='Ext-grid-selection-Model-property-rowNumbererHeaderCls'>    rowNumbererHeaderCls: Ext.baseCSSPrefix + &#39;selmodel-row-numberer-hd&#39;,
</span>
<span id='Ext-grid-Grid-event-beforeselectionextend'>    /**
</span>     * @member Ext.grid.Grid
     * @event beforeselectionextend An event fired when an extension block is extended
     * using a drag gesture. Only fired when the grid&#39;s
     * `{@link Ext.grid.Grid.selectable #cfg!selectable}` is configured with the
     * {@link Ext.grid.selection.Model#extensible extensible} config.
     *
     * @param {Ext.grid.Grid} grid The owning grid.
     * @param {Ext.dataview.selection.Selection} An object which encapsulates a contiguous
     * selection block.
     * @param {Object} extension An object describing the type and size of extension.
     * @param {String} extension.type `&quot;rows&quot;` or `&quot;columns&quot;`
     * @param {Ext.grid.Location} extension.start The start (top left) cell of the
     * extension area.
     * @param {Ext.grid.Location} extension.end The end (bottom right) cell of the
     * extension area.
     * @param {number} [extension.columns] The number of columns extended (-ve means on
     * the left side).
     * @param {number} [extension.rows] The number of rows extended (-ve means on the top
     * side).
     */

<span id='Ext-grid-Grid-event-selectionextenderdrag'>    /**
</span>     * @member Ext.grid.Grid
     * @event selectionextenderdrag An event fired when an extension block is dragged to
     * encompass a new range. Only fired when the grid&#39;s `{@link Ext.grid.Grid.selectable #cfg!selectable}`
     * is configured with the {@link Ext.grid.selection.Model#extensible extensible} config.
     * @param {Ext.grid.Grid} grid The owning grid.
     * @param {Ext.dataview.selection.Selection} An object which encapsulates a contiguous selection block.
     * @param {Object} extension An object describing the type and size of extension.
     * @param {String} extension.type `&quot;rows&quot;` or `&quot;columns&quot;`
     * @param {HTMLElement} extension.overCell The grid cell over which the mouse is being dragged.
     * @param {Ext.grid.Location} extension.start The start (top left) cell of the extension area.
     * @param {Ext.grid.Location} extension.end The end (bottom right) cell of the extension area.
     * @param {number} [extension.columns] The number of columns extended (-ve means on the left side).
     * @param {number} [extension.rows] The number of rows extended (-ve means on the top side).
     */

<span id='Ext-grid-selection-Model-method-updateView'>    /**
</span>     * @private
     */
    updateView: function (view, oldView) {
        var me = this,
            rowNumberer = me.numbererColumn = view.getRowNumbers(),
            checkbox = me.getCheckbox();

        me.callParent([view, oldView]);

        if (oldView) {
            me.navigationModel = null;
            Ext.destroy(me.viewListeners);
        }

        if (view) {
            // If there is a row numberer column we can use, add our classes to it so it can
            // get a different UI if the theme requires it. Also the header cursor is a
            // &quot;select all&quot; diagonal arrow.
            if (rowNumberer) {
                // If the grid shows a row numberer, add our class
                rowNumberer.setCell({
                    cls: me.rowNumbererCellCls
                });
                rowNumberer.setCls(me.rowNumbererHeaderCls);
            }

            if (checkbox) {
                view.registerColumn(checkbox);
            }

            me.viewListeners = view.on(me.getViewListeners());
        }
    },

<span id='Ext-grid-selection-Model-method-onViewCreated'>    /**
</span>     * @private
     * Called after the view has completed its initialization.
     * @param view
     */
    onViewCreated: function(view) {
        // Add class to add special cursor pointer to column headers
        if (this.getColumns()) {
            view.addCls(this.columnSelectCls);
        }
        this.updateHeaderState();
    },

<span id='Ext-grid-selection-Model-method-updateDrag'>    updateDrag: function (drag) {
</span>        var view = this.getView(),
            viewListeners = {
                dragstart: &#39;onViewDragStart&#39;,
                delegate: view.eventDelegate,
                scope: this
            };

        // Start a drag on longpress if touch is supported.
        if (Ext.supports.Touch) {
            viewListeners.longpress = &#39;onViewLongpress&#39;;
        }
        view.innerCt[drag ? &#39;on&#39; : &#39;un&#39;](viewListeners);
    },

<span id='Ext-grid-selection-Model-method-getSelection'>    /**
</span>     * @private
     * @param {String} what {&quot;rows&quot;/&quot;records&#39;/&quot;cells&quot;/&quot;columns&quot;} What kind of object is to be selected.
     * @param {Boolean} reset
     * @return {Ext.dataview.selection.Selection} A Selection object of the required type.
     */
    getSelection: function (what, reset) {
        // The two are interchangeable, to callers, but virtual stores use
        // row range selection as opposed to record collection.
        if (what === &#39;rows&#39; || what === &#39;records&#39;) {
            what = this.getStore().isVirtualStore ? &#39;rows&#39; : &#39;records&#39;;
        }

        var result = this.callParent(),
            config;

        // If called with a required type, ensure that the selection object
        // is of that type.
        if (what) {
            what = what.toLowerCase();
            if (!result || result.type !== what) {
                config = {
                    type: what
                };
                if (what === &#39;records&#39;) {
                    config.selected = this.getSelected();
                }
                this.setSelection(config);
                result = this.callParent();
            } else if (reset) {
                result.clear(true);
            }
        }
        return result;
    },

<span id='Ext-grid-selection-Model-method-createCheckboxColumn'>    /**
</span>     * Retrieve a configuration to be used in a HeaderContainer.
     * This should be used when checkboxSelect is set to false.
     * @private
     */
    createCheckboxColumn: function(checkboxDefaults) {
        var me = this;

        return Ext.apply({
            headerCheckbox: me.getHeaderCheckbox() !== false
        }, checkboxDefaults);
    },

<span id='Ext-grid-selection-Model-method-onHeaderTap'>    /**
</span>     * @private
     */
    onHeaderTap: function(headerCt, header, e) {
        var me = this,
            sel = me.getSelection(),
            range, columns, i;

        // A click on the numberer column toggles all
        if (header === this.numbererColumn) {
            me.toggleAll(header, e);
        }
        // A column select click: exclude the checkbox column
        else if (me.getColumns() &amp;&amp; header !== me.getCheckbox()) {

            // SHIFT means select range from last selected to here
            if (e.shiftKey &amp;&amp; sel &amp;&amp; sel.lastColumnSelected) {

                // CTRL means keep current selection
                if (!e.ctrlKey) {
                    sel.clear();
                }
                headerCt = me.getView().getHeaderContainer();
                columns = headerCt.getColumns();
                range = Ext.Array.sort([headerCt.indexOfLeaf(sel.lastColumnSelected), 
                                        headerCt.indexOf(header)], Ext.Array.numericSortFn);

                for (i = range[0]; i &lt;= range[1]; i++) {
                    me.selectColumn(columns[i], true);
                }
            } else {
                if (me.isColumnSelected(header)) {
                    me.deselectColumn(header);
                    me.getSelection().lastColumnSelected = null;
                } else {
                    me.selectColumn(header, e.ctrlKey);
                    me.getSelection().lastColumnSelected = header;
                }
            }
        }
    },

<span id='Ext-grid-selection-Model-method-toggleAll'>    /**
</span>     * @private
     */
    toggleAll: function(header, e) {
        var me = this,
            sel = me.getSelection();

        e.stopEvent();
        // Not all selected, select all
        if (!sel || !sel.isAllSelected()) {
            me.selectAll();
        } else {
            me.deselectAll();
        }
        me.updateHeaderState();
        me.lastColumnSelected = null;
    },

<span id='Ext-grid-selection-Model-method-selectByLocation'>    selectByLocation: function(location) {
</span>        //&lt;debug&gt;
        if (!location.isGridLocation) {
            Ext.raise(&#39;selectByLocation MUST be passed an Ext.grid.Location&#39;);
        }
        //&lt;/debug&gt;
        var me = this,
            record = location.record,
            column = location.column;

        if (me.getCells()) {
            me.selectCells(location, location);
        } else if (me.getRows() &amp;&amp; record) {
            this.select(record);
        } else if (me.getColumns() &amp;&amp; column) {
            me.selectColumn(column);
        }
    },

<span id='Ext-grid-selection-Model-method-updateHeaderState'>    /**
</span>     * @private
     */
    updateHeaderState: function() {
        // check to see if all records are selected
        var me = this,
            store = me.getStore(),
            sel = me.getSelection(),
            isChecked = false,
            checkHd = me.getCheckbox(),
            storeCount;

        if (store &amp;&amp; sel &amp;&amp; sel.isRows) {
            storeCount = store.getCount();
            if (store.isBufferedStore) {
                isChecked = sel.allSelected;
            } else {
                isChecked = storeCount &gt; 0 &amp;&amp; (storeCount === sel.getCount());
            }
        }

        if (checkHd) {
            checkHd.setHeaderStatus(isChecked);
        }
    },

<span id='Ext-grid-selection-Model-method-onColumnUpdate'>    /**
</span>     * Intercepts the grid&#39;s updateColumns method.  Adds the checkbox header.
     * @param headerCt
     * @param {Object[]} columns
     * @private
     */
    onColumnUpdate: function(headerCt, columns) {
        var me = this,
            checkColumn = me.getCheckbox();

        if (checkColumn) {
            // This is being called from a reconfigure operation - from updateColumns
            // so we have to preserve our column from destruction
            if (headerCt) {
                headerCt.remove(checkColumn, false);
            }

            columns.push(checkColumn);
        }
    },

<span id='Ext-grid-selection-Model-method-select'>    select: function(records, keepExisting, suppressEvent) {
</span>        // API docs are inherited
        var me = this,
            sel = me.getSelection(&#39;records&#39;),
            store = me.getStore(),
            len, i, record;

        if (!Ext.isArray(records)) {
            records = [records];
        }
        len = records.length;
        for (i = 0; i &lt; len; i++) {
            record = records[i];
            if (typeof record === &#39;number&#39;) {
                records[i] = record = store.getAt(record);
            }
        }

        // SelectionObject will call fireSelectionChange if necessary
        sel.add(records, keepExisting, suppressEvent);
    },

<span id='Ext-grid-selection-Model-method-deselect'>    deselect: function(records, suppressEvent) {
</span>        // API docs are inherited
        var me = this,
            sel = me.getSelection(&#39;records&#39;),
            store = me.getView().getStore(),
            len, i, record;

        if (sel &amp;&amp; sel.isRecords) {
            if (!Ext.isArray(records)) {
                records = [records];
            }
            len = records.length;
            for (i = 0; i &lt; len; i++) {
                record = records[i];
                if (typeof record === &#39;number&#39;) {
                    records[i] = record = store.getAt(record);
                }
            }
        }

        // SelectionObject will call fireSelectionChange if necessary
        sel.remove(records, suppressEvent);
    },

<span id='Ext-grid-selection-Model-method-onCollectionRemove'>    onCollectionRemove: function(selectedCollection, chunk) {
</span>        this.updateHeaderState();
        this.callParent([selectedCollection, chunk]);
    },

<span id='Ext-grid-selection-Model-method-onCollectionAdd'>    onCollectionAdd: function(selectedCollection, adds) {
</span>        this.updateHeaderState();
        this.callParent([selectedCollection, adds]);
    },

<span id='Ext-grid-selection-Model-method-selectCells'>    /**
</span>     * This method allows programmatic selection of the cell range.
     *
     *     @example
     *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
     *         fields  : [&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
     *         data    : {
     *             items : [
     *                 { name : &#39;Lisa&#39;,  email : &#39;lisa@simpsons.com&#39;,  phone : &#39;555-111-1224&#39; },
     *                 { name : &#39;Bart&#39;,  email : &#39;bart@simpsons.com&#39;,  phone : &#39;555-222-1234&#39; },
     *                 { name : &#39;Homer&#39;, email : &#39;homer@simpsons.com&#39;, phone : &#39;555-222-1244&#39; },
     *                 { name : &#39;Marge&#39;, email : &#39;marge@simpsons.com&#39;, phone : &#39;555-222-1254&#39; }
     *             ]
     *         },
     *         proxy   : {
     *             type   : &#39;memory&#39;,
     *             reader : {
     *                 type : &#39;json&#39;,
     *                 root : &#39;items&#39;
     *             }
     *         }
     *     });
     *
     *     var grid = Ext.create(&#39;Ext.grid.Grid&#39;, {
     *         title    : &#39;Simpsons&#39;,
     *         store    : store,
     *         width    : 400,
     *         renderTo : Ext.getBody(),
     *         columns  : [
     *            columns: [
     *               { text: &#39;Name&#39;,  dataIndex: &#39;name&#39; },
     *               { text: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex: 1 },
     *               { text: &#39;Phone&#39;, dataIndex: &#39;phone&#39;, width:120 },
     *               {
     *                   text:&#39;Combined&#39;, dataIndex: &#39;name&#39;, width : 300,
     *                   renderer: function (value, metaData, record, rowIndex,
     *                                       colIndex, store, view) {
     *                       console.log(arguments);
     *                       return value + &#39; has email: &#39; + record.get(&#39;email&#39;);
     *                   }
     *               }
     *           ],
     *         ],
     *         selType: &#39;spreadsheet&#39;
     *     });
     *
     *     var selectable = grid.getSelectable();  // get selection model
     *
     *     // We will create range of 4 cells.
     *
     *     // Now set the range  and prevent rangeselect event from being fired.
     *     // We can use a simple array when we have no locked columns.
     *     selectable.selectCells([0, 0], [1, 1], true);
     *
     * @param rangeStart {Ext.grid.Location/Number[]} Range starting position. Can be
     * either Cell context or a `[rowIndex, columnIndex]` numeric array.
     *
     * Note that when a numeric array is used in a locking grid, the column indices are
     * relative to the outermost grid, encompassing locked *and* normal sides.
     * @param rangeEnd {Ext.grid.Location/Number[]} Range end position. Can be either Cell
     * context or a `[rowIndex, columnIndex]` numeric array.
     *
     * Note that when a numeric array is used in a locking grid, the column indices are
     * relative to the outermost grid, encompassing locked *and* normal sides.
     * @param {Boolean} [suppressEvent] Pass `true` to not fire the `{@link #selectionchange}`
     * event.
     */
    selectCells: function(rangeStart, rangeEnd, suppressEvent) {
        var me = this,
            view = me.getView(),
            sel;

        rangeStart = rangeStart.isGridLocation ? rangeStart.clone() : new Ext.grid.Location(view, {
            record: rangeStart[0],
            column: rangeStart[1]
        });
        rangeEnd = rangeEnd.isGridLocation ? rangeEnd.clone() : new Ext.grid.Location(view, {
            record: rangeEnd[0],
            column: rangeEnd[1]
        });

        me.resetSelection(true);

        sel = me.getSelection(&#39;cells&#39;);
        sel.setRangeStart(rangeStart);
        sel.setRangeEnd(rangeEnd);

        if (!suppressEvent) {
            me.fireSelectionChange();
        }
    },

<span id='Ext-grid-selection-Model-method-selectAll'>    /**
</span>     * Select all the data if possible.
     *
     * If {@link #rows} is `true`, then all *records* will be selected.
     *
     * If {@link #cells} is `true`, then all *rendered cells* will be selected.
     *
     * If {@link #columns} is `true`, then all *columns* will be selected.
     *
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectAll: function (suppressEvent) {
        var me = this,
            sel = me.getSelection(),
            doSelect;

        if (me.getRows()) {
            sel = me.getSelection(&#39;records&#39;);
            doSelect = true;
        }
        else if (me.getCells()) {
            sel = me.getSelection(&#39;cells&#39;);
            doSelect = true;
        }
        else if (me.getColumns()) {
            sel = me.getSelection(&#39;columns&#39;);
            doSelect = true;
        }

        if (doSelect) {
            sel.selectAll(suppressEvent); //this populates the selection with the records
        }
    },

<span id='Ext-grid-selection-Model-method-deselectAll'>    /**
</span>     * Clears the selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    deselectAll: function (suppressEvent) {
        var sel = this.getSelection();
        
        if (sel &amp;&amp; sel.getCount()) {
            sel.clear(suppressEvent);
        }
    },

<span id='Ext-grid-selection-Model-method-selectRows'>    /**
</span>     * Select one or more rows.
     * @param rows {Ext.data.Model[]} Records to select.
     * @param {Boolean} [keepSelection=false] Pass `true` to keep previous selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectRows: function(rows, keepSelection, suppressEvent) {
        var sel = this.getSelection(&#39;records&#39;);

        if (!keepSelection) {
            this.resetSelection(true);
        }
        sel.add(rows, keepSelection, suppressEvent);
    },

<span id='Ext-grid-selection-Model-method-isSelected'>    isSelected: function(record) {
</span>        // API docs are inherited.
        return this.isRowSelected(record);
    },

<span id='Ext-grid-selection-Model-method-selectColumn'>    /**
</span>     * Selects a column.
     * @param {Ext.grid.column.Column} column Column to select.
     * @param {Boolean} [keepSelection=false] Pass `true` to keep previous selection.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    selectColumn: function(column, keepSelection, suppressEvent) {
        var selData = this.getSelection(&#39;columns&#39;);

        if (!selData.isSelected(column)) {
            if (!keepSelection) {
                selData.clear(suppressEvent);
            }
            selData.add(column);
        }
    },

<span id='Ext-grid-selection-Model-method-deselectColumn'>    /**
</span>     * Deselects a column.
     * @param {Ext.grid.column.Column} column Column to deselect.
     * @param {Boolean} [suppressEvent] Pass `true` to prevent firing the
     * `{@link #selectionchange}` event.
     */
    deselectColumn: function(column, suppressEvent) {
        var selData = this.getSelection();

        if (selData &amp;&amp; selData.isColumns &amp;&amp; selData.isSelected(column)) {
            selData.remove(column, suppressEvent);
        }
    },

<span id='Ext-grid-selection-Model-method-destroy'>    destroy: function() {
</span>        var me = this,
            view = me.getView(),
            checkbox = me.checkbox;

        if (view &amp;&amp; !view.destroying &amp;&amp; checkbox) {
            view.unregisterColumn(checkbox, true);
        }

        Ext.destroy(me.viewListeners, me.extensible);
        me.callParent();
    },

<span id='Ext-grid-selection-Model-property-privates'>    //-------------------------------------------------------------------------
</span>
    privates: {
<span id='Ext-grid-selection-Model-property-axesConfigs'>        /**
</span>         * @property {Object} axesConfigs
         * Use when converting the extensible config into a SelectionExtender to create
         * its `axes` config to specify which axes it may extend.
         * @private
         */
        axesConfigs: {
            x: 1,
            y: 2,
            xy: 3,
            both: 3,
            &quot;true&quot;: 3 // reserved word MUST be quoted when used an a property name
        },

<span id='Ext-grid-selection-Model-method-getViewListeners'>        /**
</span>         * @return {Object}
         * @private
         */
        getViewListeners: function() {
            return {
                columnschanged: &#39;onColumnsChanged&#39;,
                columnmove: &#39;onColumnMove&#39;,
                keyup: {
                    element: &#39;innerCt&#39;,
                    fn: &#39;onViewKeyUp&#39;,
                    scope: this
                },
                scope: this,
                destroyable: true
            };
        },

<span id='Ext-grid-selection-Model-method-onViewKeyUp'>        /**
</span>         * @private
         */
        onViewKeyUp: function(e) {
            var sel = this.getSelection();

            // Released the shift key, terminate a keyboard based range selection
            if (e.keyCode === e.SHIFT &amp;&amp; sel &amp;&amp; sel.isRows &amp;&amp; sel.getRangeSize()) {
                // Copy the drag range into the selected records collection
                sel.addRange();
            }
        },

<span id='Ext-grid-selection-Model-method-refreshSelection'>        /**
</span>         * @private
         */
        refreshSelection: function() {
            if (this.getSelection().isRecords) {
                this.callParent();
            }
            else {
                this.resetSelection();
            }
        },

<span id='Ext-grid-selection-Model-method-onColumnsChanged'>        /**
</span>         * @private
         */
        onColumnsChanged: function() {
            var me = this,
                selData = me.getSelection(),
                view, selectionChanged;

            // When columns have changed, we have to deselect *every* cell in the row range
            // because we do not know where the columns have gone to.
            if (selData) {
                view = selData.view;

                if (selData.isCells) {
                    if (view.visibleColumns().length) {
                        selData.eachCell(function(location) {
                            view.onCellDeselect(location);
                        });
                    } else {
                        me.clearSelections();
                    }
                }

                // We have to deselect columns which have been hidden/removed
                else if (selData.isColumns) {
                    selectionChanged = false;
                    selData.eachColumn(function(column) {
                        if (!column.isVisible() || !view.isAncestor(column)) {
                            me.remove(column);
                            selectionChanged = true;
                        }
                    });
                }
            }

            // This event is fired directly from the HeaderContainer before the view updates.
            // So we have to wait until idle to update the selection UI.
            // NB: fireSelectionChange calls updateSelectionExtender after firing its event.
            Ext.on(&#39;idle&#39;, selectionChanged ? me.fireSelectionChange : me.updateSelectionExtender, me, {
                single: true
            });
        },

        // The selection may have acquired or lost contiguity, so the replicator may need
        // enabling or disabling
        onColumnMove: function() {
            this.updateSelectionExtender();
        },

<span id='Ext-grid-selection-Model-method-resetSelection'>        /**
</span>         * @private
         */
        resetSelection: function(suppressEvent) {
            var sel = this.getSelection();

            if (sel) {
                sel.clear(suppressEvent);
            }
        },

        onViewLongpress: function(e) {
            if (e.pointerType === &#39;touch&#39;) {
                e.startDrag();
            }
        },

<span id='Ext-grid-selection-Model-method-onViewDragStart'>        /**
</span>         * Plumbing for drag selection of cell range
         * @private
         */
        onViewDragStart: function(e) {
            // For touch gestures, only initiate drags on longpress
            if (e.pointerType === &#39;touch&#39; &amp;&amp; !e.longpress) {
                return;
            }

            var me = this,
                view = me.getView(),
                location = new Ext.grid.Location(view, e),
                header = location.column,
                viewLocation = view.getNavigationModel().getLocation(),
                isCheckClick = header === me.getCheckbox(),
                sel;

            if (!location.cell) {
                return;
            }

            // Ignore right click, shift and alt modifiers.
            // Ignore when actionableMode is true so we can select the text inside an editor
            if (e.claimed || e.button &gt; 0 || e.shiftKey || e.altKey || 
                    (viewLocation &amp;&amp; viewLocation.actionable) || !view.shouldSelectItem(e)) {
                return;
            }

            if (header) {
                e.claimGesture();
                me.mousedownPosition = location.clone();

                if (isCheckClick) {
                    me.checkCellClicked = location.cell.element.dom;
                }

                // Differentiate between row and cell selections.
                if (header === me.numbererColumn || isCheckClick || !me.getCells()) {
                    // Enforce rows setting
                    if (me.getRows()) {
                        // If checkOnly is set, and we&#39;re attempting to select a row 
                        // outside of the checkbox column, reject
                        if (!isCheckClick &amp;&amp; me.checkboxOnly) {
                            return;
                        }
                        sel = me.getSelection(&#39;records&#39;);
                        if (!e.ctrlKey &amp;&amp; !isCheckClick) {
                            sel.clear();
                        }
                    } else if (me.getColumns()) {
                        sel = me.getSelection(&#39;columns&#39;);
                        if (!e.ctrlKey &amp;&amp; !isCheckClick) {
                            sel.clear();
                        }
                    } else {
                        return false;
                    }
                } else {
                    sel = me.getSelection(&#39;cells&#39;);
                    sel.clear();
                }

                me.lastDragLocation = null;

                // If it was a lomgpress, begin selection now.
                // If it was a mousemove, then there will be a drag gesture coming right along.
                if (e.longpress) {
                    location.row.removeCls(view.pressedCls);
                    me.onViewSelectionDrag(e);
                }

                // Only begin the drag process if configured to select what they asked for
                if (sel) {
                    // Add the listener after the view has potentially been corrected
                    view.innerCt.on(&#39;dragend&#39;, me.onViewDragEnd, me, { single: true });

                    me.mousemoveListener = view.innerCt.on({
                        drag: &#39;onViewSelectionDrag&#39;,
                        scope: me,
                        delegate: view.eventDelegate,
                        destroyable: true
                    });
                }
            }
        },

<span id='Ext-grid-selection-Model-method-onViewSelectionDrag'>        /**
</span>         * Selects range based on mouse movements
         * @param e
         * @private
         */
        onViewSelectionDrag: function(e) {
            me = this;
            view = me.getView();

            // The target of a Touch object remains unchanged from the touchstart target
            // even if the touch point moves outside of the original target.
            // We determine view Location from the &quot;over&quot; target, so polyfill using
            // the touch coordinates and document.elementFromPoint.
            if (e.changedTouches) {
                touch = e.changedTouches[0];

                // If the target does not contain the touch point, we have to correct it.
                if (touch &amp;&amp; !Ext.fly(touch.target).getRegion().contains(touch.point)) {
                    realTarget = Ext.event.Event.resolveTextNode(
                        Ext.Element.fromPagePoint(touch.pageX, touch.pageY, true));

                    // Points can sometimes go negative and return no target.
                    if (realTarget) {
                        e.target = realTarget;
                    }
                }
            }

            // Will fire when outside cells (on borders, row bodies and headers/footers).
            // We must only process cells.
            if (!Ext.fly(e.target).up(view.eventDelegate)) {
                return;
            }

            var me,
                view,
                newLocation = me.dragLocation = new Ext.grid.Location(view, e),
                overColumn = newLocation.column,
                overRecord = newLocation.record,
                overRowIdx = newLocation.recordIndex,
                lastDragLocation = me.lastDragLocation,
                selData, lastOverRecord, lastOverColumn, recChange, colChange, touch, realTarget;

            e.claimGesture();
            if (lastDragLocation) {
                lastOverRecord = lastDragLocation.record;
                lastOverColumn = lastDragLocation.column;
            }

            // When the mousedown happens in a checkcolumn....
            if (me.checkCellClicked) {
                selData = me.getSelection(&#39;rows&#39;);
                selData.setRangeStart(me.getStore().indexOf(overRecord));
                me.checkCellClicked = null;
                return;
            } else {
                selData = me.getSelection();
            }

            // Disable until a valid new selection is announced in fireSelectionChange
            if (me.getExtensible()) {
                me.getExtensible().disable();
            }

            if (overColumn) {
                recChange = overRecord !== lastOverRecord;
                colChange = overColumn !== lastOverColumn;

                // Initial mousedown was in rownumberer or checkbox overColumn
                if (selData.isRows || selData.isRecords) {
                    // Only react if we&#39;ve changed row
                    if (recChange) {
                        if (lastOverRecord) {
                            selData.setRangeEnd(overRowIdx);
                        } else {
                            selData.setRangeStart(overRowIdx);
                        }
                    }
                }
                // Selecting cells
                else if (selData.isCells) {
                    // Only react if we&#39;ve changed row or overColumn
                    if (recChange || colChange) {
                        if (lastOverRecord) {
                            selData.setRangeEnd(newLocation);
                        } else {
                            selData.setRangeStart(newLocation);
                        }
                    }
                }
                // Selecting columns
                else if (selData.isColumns) {
                    // Only react if we&#39;ve changed overColumn
                    if (colChange) {
                        if (lastOverColumn) {
                            selData.setRangeEnd(newLocation.column);
                        } else {
                            selData.setRangeStart(newLocation.column);
                        }
                    }
                }

                // Focus MUST follow the mouse.
                // Otherwise the focus may scroll out of the rendered range and revert to document
                if (recChange || colChange) {
                    view.getNavigationModel().setLocation(newLocation);
                }
                me.lastDragLocation = newLocation;
            }
        },

<span id='Ext-grid-selection-Model-method-onViewDragEnd'>        /**
</span>         * Clean up mousemove event
         * @param e
         * @private
         */
        onViewDragEnd: function(e) {
            var me = this,
                view = me.getView(),
                dragLocation = me.dragLocation,
                changedCell = !dragLocation || !dragLocation.equals(me.mousedownPosition),
                location = e.location;

            me.checkCellClicked = null;

            if (view &amp;&amp; !view.destroyed) {
                // If we catch the event before the View sees it and stamps a position in,
                // we need to know where they mouseupped.
                if (!location) {
                    e.location = new Ext.grid.Location(view, e);
                }

                // Disable until a valid new selection is announced in fireSelectionChange
                // unless it&#39;s a click
                if (me.getExtensible() &amp;&amp; changedCell) {
                    me.getExtensible().disable();
                }

                me.mousemoveListener.destroy();

                // Copy the records encompassed by the drag range into the record collection
                if (me.getSelection().isRows) {
                    me.getSelection().addRange();
                }

                // Fire selection change only if we have dragged - if the mouseup position
                // is different from the mousedown position.
                // If there has been no drag, the click handler will select the single row
                else if (changedCell) {
                    me.fireSelectionChange();
                }
            }
        },

<span id='Ext-grid-selection-Model-method-onNavigate'>        /**
</span>         * Called when the grid&#39;s Navigation model detects navigation events (`mousedown`,
         * `click` and certain `keydown` events).
         * @param {Ext.event.Event} navigateEvent The event which caused navigation.
         * @private
         */
        onNavigate: function(navigateEvent) {
            var me = this,
                selectingRows = me.getRows(),
                selectingCells = me.getCells(),
                selectingColumns = me.getColumns(),
                checkbox = me.getCheckbox(),
                checkboxOnly = me.checkboxOnly,
                mode = me.getMode(),
                location = navigateEvent.to,
                toColumn = location.column,
                record = location.record,
                sel = me.getSelection(),
                ctrlKey = navigateEvent.ctrlKey,
                shiftKey = navigateEvent.shiftKey,
                changedRow, selectionChanged;

            // Honour the stopSelection flag which any prior handlers may set.
            // A SelectionColumn handles its own processing.
            if (navigateEvent.stopSelection || toColumn === me.checkboxColumn) {
                return;
            }

            // *key* navigation
            if (!navigateEvent.pointerType &amp;&amp; navigateEvent.getKey() !== navigateEvent.SPACE) {
                // CTRL/key just navigates, does not select
                if (ctrlKey) {
                    return;
                }

                // If within a row and not going to affect cell or column selection, then ignore.
                changedRow = !navigateEvent.from || (location.recordIndex !== navigateEvent.from.recordIndex);
                if (!changedRow &amp;&amp; !(selectingCells || selectingColumns)) {
                    return;
                }
            }

            // Click is the mouseup at the end of a multi-cell/multi-column select swipe; reject.
            if (sel &amp;&amp; (sel.isCells || (sel.isColumns &amp;&amp; selectingRows &amp;&amp; !(ctrlKey || shiftKey))) &amp;&amp;
                    sel.getCount() &gt; 1 &amp;&amp; !shiftKey &amp;&amp; navigateEvent.type === &#39;click&#39;) {
                return;
            }

            // If all selection types are disabled, or it&#39;s not a selecting event, return
            if (!(selectingCells || selectingColumns || selectingRows) || !record || 
                    navigateEvent.type === &#39;mousedown&#39;) {
                return;
            }

            // Ctrl/A key - Deselect current selection, or select all if no selection
            if (ctrlKey &amp;&amp; navigateEvent.keyCode === navigateEvent.A &amp;&amp; mode === &#39;multi&#39;) {
                // No selection, or only one, select all
                if (!sel || sel.getCount() &lt; 2) {
                    me.selectAll();
                } else {
                    me.deselectAll();
                }
                me.updateHeaderState();
                return;
            }

            if (shiftKey &amp;&amp; mode === &#39;multi&#39;) {
                // If the event is in one of the row selecting cells, or cell selecting is
                // turned off
                if (toColumn === me.numbererColumn || toColumn === me.checkColumn || 
                        !(selectingCells || selectingColumns) ||
                        (sel &amp;&amp; (sel.isRows || sel.isRecords))) {
                    if (selectingRows) {
                        // If checkOnly is set, and we&#39;re attempting to select a row outside
                        // of the checkbox column, reject
                        if (toColumn !== checkbox &amp;&amp; checkboxOnly) {
                            return;
                        }
                        // Ensure selection object is of the correct type
                        sel = me.getSelection(&#39;records&#39;);
                        // First shift
                        if (!sel.getRangeSize()) {
                            sel.setRangeStart(me.selectionStart || location.recordIndex);
                        }
                        sel.setRangeEnd(location.recordIndex);
                        sel.addRange(true);
                        selectionChanged = true;
                    }
                }
                // Navigate event in a normal cell
                else {
                    if (selectingCells) {
                        // Ensure selection object is of the correct type
                        sel = me.getSelection(&#39;cells&#39;);
                        // First shift
                        if (!sel.getRangeSize()) {
                            sel.setRangeStart(navigateEvent.from || new Ext.grid.Location(me.getView(), {
                                record: 0,
                                column: 0
                            }));
                        }
                        sel.setRangeEnd(location);
                        selectionChanged = true;
                    } else if (selectingColumns) {
                        // Ensure selection object is of the correct type
                        sel = me.getSelection(&#39;columns&#39;);
                        if (!sel.getCount()) {
                            sel.setRangeStart(toColumn);
                        }
                        sel.setRangeEnd(toColumn);
                        selectionChanged = true;
                    }
                }
            } else {
                me.selectionStart = null;
                if (sel &amp;&amp; mode !== &#39;multi&#39;) {
                    sel.clear(true);
                }

                // If we are selecting rows and (the event is in one of the row selecting
                // cells or we&#39;re *only* selecting rows) then select this row
                if (selectingRows &amp;&amp; (toColumn === me.numbererColumn ||
                        toColumn === checkbox || !selectingCells)) {
                    // If checkOnly is set, and we&#39;re attempting to select a row outside
                    // of the checkbox column, reject
                    // Also reject if we&#39;re navigating by key within the same row.
                    if (toColumn !== checkbox &amp;&amp; checkboxOnly || (navigateEvent.keyCode &amp;&amp;
                            navigateEvent.from &amp;&amp; record === navigateEvent.from.record)) {
                        return;
                    }

                    // Ensure selection object is of the correct type
                    sel = me.getSelection(&#39;records&#39;);

                    if (sel.isSelected(record)) {
                        if (ctrlKey || toColumn === checkbox || me.getDeselectable()) {
                            sel.remove(record);
                            selectionChanged = true;
                        }
                    } else {
                        sel.add(record, ctrlKey || toColumn === checkbox);
                        selectionChanged = true;
                    }
                    me.selectionStart = location.recordIndex;
                }
                // Navigate event in a normal cell
                else {
                    // Prioritize cell selection over column selection
                    if (selectingCells) {
                        // Ensure selection object is of the correct type and cleared.
                        sel = me.getSelection(&#39;cells&#39;, true);
                        sel.setRangeStart(location);
                        selectionChanged = true;
                    }
                    else if (selectingColumns) {
                        // Ensure selection object is of the correct type
                        sel = me.getSelection(&#39;columns&#39;);

                        if (ctrlKey) {
                            if (sel.isSelected(toColumn)) {
                                sel.remove(toColumn);
                            } else {
                                sel.add(toColumn);
                            }
                        } else {
                            sel.setRangeStart(toColumn);
                        }
                        selectionChanged = true;
                    }
                }
            }

            // If our configuration allowed selection changes, update check header and fire event
            if (selectionChanged) {
                // Base class reacts to RecordSelection mutating its record Collection
                // It will fire the events and update the checked header state.
                if (!sel.isRecords) {
                    me.fireSelectionChange(null, true);
                }
            }
        },

<span id='Ext-grid-selection-Model-method-isColumnSelected'>        /**
</span>         * Check if given column is currently selected.
         *
         * @param {Ext.grid.column.Column} column
         * @return {Boolean}
         * @private
         */
        isColumnSelected: function(column) {
            var me = this,
                sel = me.getSelection(),
                ret = false;

            if (sel &amp;&amp; sel.isColumns) {
                ret = sel.isSelected(column);
            }

            return ret;
        },

<span id='Ext-grid-selection-Model-method-isCellSelected'>        /**
</span>         * Returns true if specified cell within specified view is selected
         *
         * Used in {@link Ext.grid.Row} rendering to decide upon cell UI treatment.
         * @param {Number/Ext.grid.Location/Ext.data.Model} row - The Row index/record or
         * {@link Ext.grid.Location the grid Location} to test.
         * @param {Number} column - Column index to test.
         *
         * @return {Boolean}
         * @private
         */
        isCellSelected: function(row, column) {
            var sel = this.getSelection();

            if (sel) {
                if (sel.isColumns) {
                    if (typeof column === &#39;number&#39;) {
                        column = this.getView().getVisibleColumns()[column];
                    }
                    return sel.isSelected(column);
                }

                if (sel.isCells) {
                    return sel.isSelected(row, column);
                }

                // We&#39;re selecting records or rows.
                // The cell is selected if the record is.
                return sel.isSelected(row);
            }

            return false;
        },

<span id='Ext-grid-selection-Model-method-updateSelection'>        /**
</span>         * @private
         */
        updateSelection: function(selection, oldSelection) {
            var view = this.getView();

            // Destroy old selection.
            Ext.destroy(oldSelection);

            // Update the UI to match the new selection
            if (selection &amp;&amp; selection.getCount()) {
                view = selection.view;

                // Rows; update each selection row
                if (selection.isRows) {
                    selection.eachRow(view.onRowSelect, view);
                }
                // Columns; update the selection columns for all rows
                else if (selection.isColumns) {
                    selection.eachCell(view.onCellSelect, view);
                }
                // Cells; update each selection cell
                else if (selection.isCells) {
                    selection.eachCell(view.onCellSelect, view);
                }
            }
        },

<span id='Ext-grid-selection-Model-method-updateRows'>        /**
</span>         * Show/hide the extra column headers depending upon rowSelection.
         * @private
         */
        updateRows: function(rows) {
            var sel;

            if (!rows) {
                // checkboxSelect depends on rowsSelect
                this.setCheckbox(false);

                sel = this.getSelection()
                if (sel &amp;&amp; sel.isRows) {
                    sel.clear();
                }
            }
        },

<span id='Ext-grid-selection-Model-method-updateColumns'>        /**
</span>         * Enable/disable the HeaderContainer&#39;s sortOnClick in line with column select on
         * column click.
         * @private
         */
        updateColumns: function(columns) {
            var me = this,
                view = me.getView(),
                sel = me.getSelection();

            if (!columns &amp;&amp; sel &amp;&amp; sel.isColumns) {
                sel.clear();
                me.fireSelectionChange();
            }
            view.toggleCls(me.columnSelectCls, !!columns);
        },

<span id='Ext-grid-selection-Model-method-updateCells'>        /**
</span>         * @private
         */
        updateCells: function(cells) {
            var me = this,
                sel = me.getSelection();

            if (!cells &amp;&amp; sel &amp;&amp; sel.isCells) {
                sel.clear();
                me.fireSelectionChange();
            }
        },

        updateMode: function(mode) {
            // If multi, we can use drag or not, so revert to initial value
            if (mode === &#39;multi&#39;) {
                this.setDrag(this.getInitialConfig().drag);
            }
            // With &#39;simple&#39; or &#39;single&#39;, drag makes no sense
            else if (!this.isConfiguring) {
                this.setDrag(false);
            }
        },

<span id='Ext-grid-selection-Model-method-fireSelectionChange'>        /**
</span>         * @private
         * @param {Ext.data.Model[]} records. *ONLY* passed if called from the base class&#39;s
         * onCollectionAdd/Remove observers on the *record* collection.
         * @param {Boolean} selecting. *ONLY* passed if called from the base class&#39;s
         * onCollectionAdd/Remove observers on the *record* collection.
         */
        fireSelectionChange: function(records, selecting) {
            var me = this,
                view = me.getView(),
                selection = me.getSelection();

            // Inform selection object that we&#39;re done
            me.updateSelectionExtender();

            // Our own event
            me.fireEvent(&#39;selectionchange&#39;, view,  me.getSelection());

            // Fire Grid&#39;s selectionchange event.
            // Only pass records if the selection type can yield them
            view.fireEvent(&#39;selectionchange&#39;, view, 
                    selection.isRecords ? records : 
                           (selection.isCells ? selection.getRecords() : null),
                    selecting, me.getSelection());
        },

        updateSelectionExtender: function() {
            var sel = this.getSelection();
            if (sel) {
                sel.onSelectionFinish();
            }
        },

<span id='Ext-grid-selection-Model-method-onSelectionFinish'>        /**
</span>         * Called when a selection has been made. The selection object&#39;s onSelectionFinish
         * calls back into this.
         * @param {Ext.dataview.selection.Selection} sel The selection object specific to
         * the selection performed.
         * @param {Ext.grid.Location} [firstCell] The left/top most selected cell.
         * Will be undefined if the selection is clear.
         * @param {Ext.grid.Location} [lastCell] The bottom/right most selected cell.
         * Will be undefined if the selection is clear.
         * @private
         */
        onSelectionFinish: function(sel, firstCell, lastCell) {
            var extensible = this.getExtensible();

            if (extensible) {
                extensible.setHandle(firstCell, lastCell);
            }
        },

        applyExtensible: function(extensible, oldExtensible) {
            var me = this,
                axes;

            // if extensible is false/null we should return undefined so the value
            // does not get set and we don&#39;t call updateExtensible
            if (!extensible) {
                return undefined;
            }

            if (extensible === true || typeof extensible === &#39;string&#39;) {
                axes = me.axesConfigs[extensible];

                // if we already have an extensible, just update it&#39;s config
                if (oldExtensible) {
                    oldExtensible.setAxes(axes);
                    return oldExtensible;
                }

                extensible = {
                    axes: axes
                };
            } else {
                extensible = Ext.Object.chain(extensible); // don&#39;t mutate the user&#39;s config
            }

            extensible.view = me.getView();

            // if this wasn&#39;t a simple axes update, destroy the old extensible
            // so we don&#39;t end up with multiple extensibles on the view.
            if (oldExtensible) {
                oldExtensible.destroy();
            }

            return new Ext.grid.selection.SelectionExtender(extensible);
        },

        applyCheckbox: function(checkbox) {
            var me = this;

            if (checkbox) {
                me.checkboxOnly = checkbox === &#39;only&#39;;
                me.checkboxColumn = checkbox = Ext.create(me.createCheckboxColumn(
                        me.getCheckboxDefaults()));
            }

            return checkbox;
        },

        updateCheckbox: function(checkbox, oldCheckbox) {
            var me = this,
                view;

            if (!me.isConfiguring) {
                view = me.getView();
                if (oldCheckbox) {
                    view.unregisterColumn(oldCheckbox, true);
                }

                if (checkbox) {
                    view.registerColumn(checkbox);
                    // rows selection is required so force it
                    me.setRows(true);
                }
            }
        },

        applyView: function(view) {
            // In a locking assembly, we talk to the owner
            return view.ownerGrid;
        },

<span id='Ext-grid-selection-Model-method-extendSelection'>        /**
</span>         * Called when the SelectionExtender has the mouse released.
         * @param {Object} extension An object describing the type and size of extension.
         * @param {String} extension.type `&quot;rows&quot;` or `&quot;columns&quot;`
         * @param {Ext.grid.Location} extension.start The start (top left) cell of the
         * extension area.
         * @param {Ext.grid.Location} extension.end The end (bottom right) cell of the
         * extension area.
         * @param {number} [extension.columns] The number of columns extended (-ve means
         * on the left side).
         * @param {number} [extension.rows] The number of rows extended (-ve means on the
         * top side).
         * @private
         */
        extendSelection: function(extension) {
            var me = this,
                view = me.getView(),
                sel = me.getSelection();

            // Announce that the selection is to be extended, and if no objections, extend it
            if (view.fireEvent(&#39;beforeselectionextend&#39;, view, sel, extension) !== false) {
                sel.extendRange(extension);

                // Base class reacts to RowSelection mutating its record Collection
                // It will fire the events.
                if (!sel.isRows) {
                    me.fireSelectionChange();
                }
            }
        },

<span id='Ext-grid-selection-Model-method-onIdChanged'>        /**
</span>         * @private
         */
        onIdChanged: function(store, rec, oldId, newId) {
            var sel = this.getSelection();

            if (sel &amp;&amp; sel.isRecords) {
                sel.getSelected().updateKey(rec, oldId);
            }
        },

<span id='Ext-grid-selection-Model-method-onSelectionStoreAdd'>        /**
</span>         * @private
         */
        onSelectionStoreAdd: function() {
            this.callParent(arguments);
            this.updateHeaderState();
        },

<span id='Ext-grid-selection-Model-method-onSelectionStoreClear'>        /**
</span>         * @private
         */
        onSelectionStoreClear: function() {
            this.callParent(arguments);
            this.updateHeaderState();
        },

<span id='Ext-grid-selection-Model-method-onSelectionStoreLoad'>        /**
</span>         * @private
         */
        onSelectionStoreLoad: function() {
            this.callParent(arguments);
            this.updateHeaderState();
        }
    }
}, function (GridModel) {
    var RowNumberer = Ext.ClassManager.get(&#39;Ext.grid.column.RowNumberer&#39;),
        cellCls;

    if (RowNumberer) {
        cellCls = Ext.grid.column.RowNumberer.prototype.cellCls;
        // This class adds the e-resize cursor on hover to indicate availability of selection
        GridModel.prototype.rowNumbererCellCls =
            (cellCls ? (cellCls + &#39; &#39;) : &#39;&#39;) + Ext.baseCSSPrefix + &#39;selmodel-row-numberer-cell&#39;;
    }
});
</pre>
</body>
</html>
