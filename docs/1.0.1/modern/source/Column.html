<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-grid-column-Column'>/**
</span> * This class specifies the definition for a column inside a {@link Ext.grid.Grid}. It
 * encompasses both the grid header configuration as well as displaying data within the
 * grid itself.
 *
 * In general an array of column configurations will be passed to the grid:
 *
 *     @example
 *     Ext.create({
 *         xtype: &#39;grid&#39;,
 *         title: &#39;Tree Grid Demo&#39;,
 *         itemConfig: {
 *             viewModel: true
 *         },
 *         store: {
 *              data: [
 *                  {firstname:&quot;Michael&quot;, lastname:&quot;Scott&quot;, seniority:7, department:&quot;Management&quot;, hired:&quot;01/10/2004&quot;},
 *                  {firstname:&quot;Dwight&quot;, lastname:&quot;Schrute&quot;, seniority:2, department:&quot;Sales&quot;, hired:&quot;04/01/2004&quot;},
 *                  {firstname:&quot;Jim&quot;, lastname:&quot;Halpert&quot;, seniority:3, department:&quot;Sales&quot;, hired:&quot;02/22/2006&quot;},
 *                  {firstname:&quot;Kevin&quot;, lastname:&quot;Malone&quot;, seniority:4, department:&quot;Accounting&quot;, hired:&quot;06/10/2007&quot;},
 *                  {firstname:&quot;Angela&quot;, lastname:&quot;Martin&quot;, seniority:5, department:&quot;Accounting&quot;, hired:&quot;10/21/2008&quot;}
 *              ]
 *         },
 *         columns: [
 *             {text: &#39;First Name&#39;,  dataIndex:&#39;firstname&#39;},
 *             {text: &#39;Last Name&#39;,  dataIndex:&#39;lastname&#39;},
 *             {text: &#39;Hired Month&#39;,  dataIndex:&#39;hired&#39;},
 *             {
 *                 text: &#39;Department&#39;,
 *                 width: 200,
 *                 cell: {
 *                    bind: &#39;{record.department} ({record.seniority})&#39;
 *                 }
 *             }
 *         ],
 *         width: 500,
 *         fullscreen: true
 *     });
 *
 * # Convenience Subclasses
 *
 * There are several column subclasses that provide default rendering for various data types
 *
 *  - {@link Ext.grid.column.Boolean}: Renders for boolean values
 *  - {@link Ext.grid.column.Date}: Renders for date values
 *  - {@link Ext.grid.column.Number}: Renders for numeric values
 *
 * For more information about configuring cell content, see {@link Ext.grid.Grid}.
 *
 * # Setting Sizes
 *
 * The columns can be only be given an explicit width value. If no width is specified the
 * grid will automatically the size the column to 20px.
 *
 * # Header Options
 *
 *  - {@link #text}: Sets the header text for the column
 *  - {@link #sortable}: Specifies whether the column can be sorted by clicking the header
 *    or using the column menu
 *
 * # Data Options
 *
 *  - {@link #dataIndex}: The dataIndex is the field in the underlying {@link Ext.data.Store}
 *    to use as the value for the column.
 *  - {@link #renderer}: Allows the underlying store value to be transformed before being
 *    displayed in the grid.
 */
Ext.define(&#39;Ext.grid.column.Column&#39;, {
    extend: &#39;Ext.grid.HeaderContainer&#39;,
    alternateClassName: &#39;Ext.grid.column.Template&#39;,

    xtype: [&#39;gridcolumn&#39;, &#39;column&#39;, &#39;templatecolumn&#39;],

<span id='Ext-grid-column-Column-property-isGridColumn'>    /**
</span>     * @property {Boolean} isGridColumn
     * Set in this class to identify, at runtime, instances which are not instances of the
     * HeaderContainer base class, but are in fact, the subclass: Ext.grid.Column.
     */
    isGridColumn: true,

    mixins: [
        // This mixin is used to cache the padding size for cells in this column,
        // to be shared by all cells in the column.
        &#39;Ext.mixin.StyleCacher&#39;,
        &#39;Ext.mixin.Toolable&#39;
    ],

<span id='Ext-grid-column-Column-property-isLeafHeader'>    /**
</span>     * @property {Boolean} isLeafHeader
     * This will be set to `true` if the column has no child columns.
     */

<span id='Ext-grid-column-Column-property-isHeaderGroup'>    /**
</span>     * @property {Boolean} isHeaderGroup
     * This will be set to `true` if the column has child columns.
     */

    config: {
<span id='Ext-grid-column-Column-cfg-align'>        /**
</span>         * @cfg {String} [align=&#39;left&#39;]
         * Sets the alignment of the header and rendered columns.
         * Possible values are: `&#39;left&#39;`, `&#39;center&#39;`, and `&#39;right&#39;`.
         */
        align: undefined, // undefined so applier will run to determine default value

<span id='Ext-grid-column-Column-cfg-cell'>        /**
</span>         * @cfg {Object} cell
         * The config object used to create {@link Ext.grid.cell.Base cells} for this column.
         * By default, cells use the {@link Ext.grid.cell.Cell gridcell} `xtype`. To create
         * a different type of cell, simply provide this config and the desired `xtype`.
         */
        cell: {
            xtype: &#39;gridcell&#39;
        },

<span id='Ext-grid-column-Column-cfg-dataIndex'>        /**
</span>         * @cfg {String} dataIndex
         * The name of the field in the grid&#39;s {@link Ext.data.Store}&#39;s {@link Ext.data.Model} definition from
         * which to draw the column&#39;s value. **Required.**
         */
        dataIndex: null,

<span id='Ext-grid-column-Column-cfg-defaultWidth'>        /**
</span>         * @cfg {Number} defaultWidth
         * A width to apply if the {@link #flex} or {@link #width} configurations have not
         * been specified.
         *
         * @since 6.2.0
         */
        defaultWidth: 100,

<span id='Ext-grid-column-Column-cfg-depends'>        /**
</span>         * @cfg {String[]} depends
         * Set this config to the field names that effect this column&#39;s rendering. This is
         * important for best performance when using a `renderer`, a `summaryRenderer` or
         * a `tpl` to render the cell&#39;s content. This is because such mechanisms can use
         * any field and as such must be refreshed on *any* field change. When this config
         * is provided, only changes to these fields (or the `dataIndex`) will cause a
         * refresh.
         *
         * When not using these mechanisms, only changes to the `dataIndex` will cause the
         * cell content to be refreshed.
         * @since 6.5.1
         */
        depends: null,

<span id='Ext-grid-column-Column-cfg-emptyText'>        emptyText: {
</span>            cached: true,
            $value: &#39;\xA0&#39;
        },

<span id='Ext-grid-column-Column-cfg-text'>        /**
</span>         * @cfg {String} text
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         * **Note**: to have a clickable header with no text displayed you can use the default of `&amp;#160;` aka `&amp;nbsp;`.
         */
        text: &#39;\xa0&#39;,

<span id='Ext-grid-column-Column-cfg-sortable'>        /**
</span>         * @cfg {Boolean} sortable
         * False to disable sorting of this column. Whether local/remote sorting is used is specified in
         * `{@link Ext.data.Store#remoteSort}`.
         */
        sortable: true,

<span id='Ext-grid-column-Column-cfg-groupable'>        /**
</span>         * @cfg {Boolean} groupable
         * If the grid is {@link Ext.grid.Grid#grouped grouped}, the menu for this column will
         * offer to &quot;Group by this column&quot; if this is set to `true`.
         *
         * If using the {@link Ext.grid.plugin.ViewOptions ViewOptions} plugin, this option may be used to
         * disable the option to group by this column.
         */
        groupable: true,

<span id='Ext-grid-column-Column-cfg-resizable'>        /**
</span>         * @cfg {Boolean} resizable
         * False to prevent the column from being resizable.
         * Note that this configuration only works when the
         * {@link Ext.grid.plugin.ColumnResizing ColumnResizing} plugin is enabled on the
         * {@link Ext.grid.Grid Grid}.
         */
        resizable: true,

<span id='Ext-grid-column-Column-cfg-hideable'>        /**
</span>         * @cfg {Boolean} hideable
         * False to prevent the user from hiding this column.
         *
         * @since 6.5.0
         */
        hideable: true,

<span id='Ext-grid-column-Column-cfg-renderer'>        /**
</span>         * @cfg {Function/String} renderer
         * A renderer is a method which can be used to transform data (value, appearance, etc.)
         * before it is rendered.
         *
         * For example:
         *
         *      {
         *          text: &#39;Some column&#39;,
         *          dataIndex: &#39;fieldName&#39;,
         *
         *          renderer: function (value, record) {
         *              if (value === 1) {
         *                  return &#39;1 person&#39;;
         *              }
         *              return value + &#39; people&#39;;
         *          }
         *      }
         *
         * If a string is supplied, it should be the name of a renderer method from the
         * appropriate {@link Ext.app.ViewController}.
         *
         * This config is only processed if the {@link #cell} type is the default of
         * {@link Ext.grid.cell.Cell gridcell}.
         *
         * **Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
         * to rendering cell content.
         *
         * @cfg {Object} renderer.value The data value for the current cell.
         * @cfg {Ext.data.Model} renderer.record The record for the current row.
         * @cfg {Number} renderer.dataIndex The dataIndex of the current column.
         * @cfg {Ext.grid.cell.Base} renderer.cell The current cell.
         * @cfg {Ext.grid.column.Column} renderer.column The current column.
         * @cfg {String} renderer.return The HTML string to be rendered. *Note*: to
         * render HTML into the cell, you will have to configure the column&#39;s {@link #cell}
         * with `encodeHtml: false`
         */
        renderer: null,

<span id='Ext-grid-column-Column-cfg-formatter'>        /**
</span>         * @cfg {String} formatter
         * This config accepts a format specification as would be used in a `Ext.Template`
         * formatted token. For example `&#39;round(2)&#39;` to round numbers to 2 decimal places
         * or `&#39;date(&quot;Y-m-d&quot;)&#39;` to format a Date.
         *
         * In previous releases the `renderer` config had limited abilities to use one
         * of the `Ext.util.Format` methods but `formatter` now replaces that usage and
         * can also handle formatting parameters.
         *
         * When the value begins with `&quot;this.&quot;` (for example, `&quot;this.foo(2)&quot;`), the
         * implied scope on which &quot;foo&quot; is found is the `scope` config for the column.
         *
         * If the `scope` is not given, or implied using a prefix of `&quot;this&quot;`, then either the
         * {@link #method-getController ViewController} or the closest ancestor component
         * configured as {@link #defaultListenerScope} is assumed to be the object with the
         * method.
         * @since 6.2.0
         */
        formatter: null,

<span id='Ext-grid-column-Column-cfg-scope'>        /**
</span>         * @cfg {Object} scope
         * The scope to use when calling the {@link #renderer} or {@link #formatter} function.
         */
        scope: null,

<span id='Ext-grid-column-Column-cfg-editable'>        /**
</span>         * @cfg {Boolean} editable
         * Set this to true to make this column editable.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editable Editable} plugin.
         */
        editable: null,

<span id='Ext-grid-column-Column-cfg-editor'>        /**
</span>         * @cfg {Object/String} editor
         * The `xtype` or config object for a {@link Ext.field.Field Field} to use for
         * editing. This config is used by the {@link Ext.grid.plugin.Editable grideditable}
         * plugin.
         *
         * If this config is not set, and {@link #editable} is set to true, the
         * {@link #defaultEditor} is used.
         */
        editor: null,

<span id='Ext-grid-column-Column-cfg-defaultEditor'>        /**
</span>         * @cfg {Object/Ext.field.Field} defaultEditor
         * An optional config object that should not really be modified. This is used to
         * create a default editor used by the {@link Ext.grid.plugin.Editable grideditable}
         * plugin when no {@link #editor} is specified.
         */
        defaultEditor: {
            lazy: true,
            $value: {}
        },

<span id='Ext-grid-column-Column-cfg-ignore'>        /**
</span>         * @cfg {Boolean} ignore
         * Setting to `true` prevents this column from being used by plugins such as
         * {@link Ext.grid.plugin.ViewOptions} or {@link Ext.grid.plugin.Summary}. It is
         * intended for special columns such as the row number or checkbox selection.
         */
        ignore: false,

<span id='Ext-grid-column-Column-cfg-ignoreExport'>        /**
</span>         * @cfg {Boolean} ignoreExport
         * This flag indicates that this column will be ignored when grid data is exported.
         *
         * When grid data is exported you may want to export only some columns that are important
         * and not everything. You can set this flag on any column that you want to be ignored during export.
         *
         * This is used by {@link Ext.grid.plugin.Exporter exporter plugin}.
         */
        ignoreExport: false,

<span id='Ext-grid-column-Column-cfg-exportStyle'>        /**
</span>         * @cfg {Ext.exporter.file.Style/Ext.exporter.file.Style[]} exportStyle
         *
         * A style definition that is used during data export via the {@link Ext.grid.plugin.Exporter exporter plugin}.
         * This style will be applied to the columns generated in the exported file.
         *
         * You could define it as a single object that will be used by all exporters:
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          exportStyle: {
         *              format: &#39;Currency&#39;,
         *              alignment: {
         *                  horizontal: &#39;Right&#39;
         *              },
         *              font: {
         *                  italic: true
         *              }
         *          }
         *      }
         *
         * You could also define it as an array of objects, each object having a `type` that specifies by
         * which exporter will be used:
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          exportStyle: [{
         *              type: &#39;html&#39;, // used by the `html` exporter
         *              format: &#39;Currency&#39;,
         *              alignment: {
         *                  horizontal: &#39;Right&#39;
         *              },
         *              font: {
         *                  italic: true
         *              }
         *          },{
         *              type: &#39;csv&#39;, // used by the `csv` exporter
         *              format: &#39;General&#39;
         *          }]
         *      }
         *
         * Or you can define it as an array of objects that has:
         *
         * - one object with no `type` key that is considered the style to use by all exporters
         * - objects with the `type` key defined that are exceptions of the above rule
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          exportStyle: [{
         *              // no type defined means this is the default
         *              format: &#39;Currency&#39;,
         *              alignment: {
         *                  horizontal: &#39;Right&#39;
         *              },
         *              font: {
         *                  italic: true
         *              }
         *          },{
         *              type: &#39;csv&#39;, // only the CSV exporter has a special style
         *              format: &#39;General&#39;
         *          }]
         *      }
         *
         */
        exportStyle: null,

<span id='Ext-grid-column-Column-cfg-exportRenderer'>        /**
</span>         * @cfg {Boolean/Function/String} exportRenderer
         *
         * During data export via the {@link Ext.grid.plugin.Exporter} plugin the data for
         * this column could be formatted in multiple ways:
         *
         * - using the `exportStyle.format`
         * - using the `formatter` if no `exportStyle` is defined
         * - using the `exportRenderer`
         *
         * If you want to use the `renderer` defined on this column then set `exportRenderer`
         * to `true`. Beware that this should only happen if the `renderer` deals only with
         * data on the record or value and it does NOT style the cell or returns an html
         * string.
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          text: &#39;Price&#39;,
         *          renderer: function (value, record, dataIndex, cell, column) {
         *              return Ext.util.Format.currency(value);
         *          },
         *          exportRenderer: true
         *      }
         *
         * If you don&#39;t want to use the `renderer` during export but you still want to format
         * the value in a special way then you can provide a function to `exportRenderer` or
         * a string (which is a function name on the ViewController).
         * The provided function has the same signature as the renderer.
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          text: &#39;Price&#39;,
         *          exportRenderer: function (value, record, dataIndex, cell, column) {
         *              return Ext.util.Format.currency(value);
         *          }
         *      }
         *
         *
         *      {
         *          xtype: &#39;numbercolumn&#39;,
         *          dataIndex: &#39;price&#39;,
         *          text: &#39;Price&#39;,
         *          exportRenderer: &#39;exportAsCurrency&#39; // this is a function on the ViewController
         *      }
         *
         *
         * If `exportStyle.format`, `formatter` and `exportRenderer` are all defined on the
         * column then the `exportStyle` wins and will be used to format the data for this
         * column.
         */
        exportRenderer: false,

<span id='Ext-grid-column-Column-cfg-summary'>        /**
</span>         * @cfg {String} summary
         * This config replaces the default mechanism of acquiring a summary result from
         * the summary record. When specified, this string is the name of a summary type:
         *
         *  - {@link Ext.data.summary.Average average}
         *  - {@link Ext.data.summary.Count count}
         *  - {@link Ext.data.summary.Max max}
         *  - {@link Ext.data.summary.Min min}
         *  - {@link Ext.data.summary.Sum sum}
         *
         * The summary is based on either the {@link #cfg!summaryDataIndex} or the
         * {@link #cfg!dataIndex} if there is no `summaryDataIndex`.
         *
         * This config is only valid when all data is available client-side to calculate
         * summaries.
         *
         * It is generally best to allow the summary {@link Ext.data.Model record} to
         * computer summary values (and not use this config). In some cases, however,
         * this config can be useful to isolate summary calculations to only certain grids.
         *
         * To implement a custom summary for a column, use {@link #cfg!summaryRenderer}.
         * @since 6.5.0
         */
        summary: null,

<span id='Ext-grid-column-Column-cfg-summaryCell'>        /**
</span>         * @cfg {Object} summaryCell
         * The config object used to create {@link Ext.grid.cell.Base cells} in
         * {@link Ext.grid.SummaryRow Summary Rows} for this column.
         */
        summaryCell: null,

<span id='Ext-grid-column-Column-cfg-summaryDataIndex'>        /**
</span>         * @cfg {String} summaryDataIndex
         * For {@link Ext.grid.SummaryRow summary rows} this config overrides the normal
         * `dataIndex` to use from the summary record.
         * @since 6.5.0
         */
        summaryDataIndex: null,

<span id='Ext-grid-column-Column-cfg-summaryFormatter'>        /**
</span>         * @cfg {String} summaryFormatter
         * This summaryFormatter is similar to {@link #formatter} but is called before
         * displaying a value in the SummaryRow. The config is optional, if not specified
         * the default calculated value is shown. The summaryFormatter is called with:
         *
         *  - value: The calculated value.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.Summary gridsummary} plugin enabled.
         */
        summaryFormatter: null,

<span id='Ext-grid-column-Column-cfg-summaryRenderer'>        /**
</span>         * @cfg {Function/String} summaryRenderer
         * This summaryRenderer is called to render the value to display in a cell of a
         * summary row. If the value of this config is a String, it is the name of the
         * renderer method on the associated {@link Ext.Component#controller controller}.
         *
         * @cfg {Mixed} summaryRenderer.value The summary value to render. This value is
         * retrieved from the summary record based on the {@link #cfg!summaryDataIndex} or
         * {@link #cfg!dataIndex}, or by applying the {@link #cfg!summary} algorithm to
         * the appropriate records. While this value can be useful, it can also be ignored
         * and the renderer method can use the `context` information to determine the value
         * to render entirely on its own.
         *
         * @cfg {Object} summaryRenderer.context The summary context object.
         *
         * @cfg {String} summaryRenderer.context.dataIndex The data field. This will be
         * either the {@link #cfg!summaryDataIndex} if one is specified, or the normal
         * {@link #cfg!dataIndex} if not.
         *
         * @cfg {String} summaryRenderer.context.group The {@link Ext.data.Group group}
         * being summarized. This is `null` if the summary is for the whole `store`.
         *
         * @cfg {String} summaryRenderer.context.store The {@link Ext.data.Store store}
         * being summarized.
         *
         * If this method returns `undefined`, no update is made to the cell. Instead it
         * is assumed that the `summaryRenderer` has made all of the necessary changes.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.Summary gridsummary} plugin enabled.
         */
        summaryRenderer: null,

<span id='Ext-grid-column-Column-cfg-summaryType'>        /**
</span>         * @cfg {String/Function} summaryType
         * This configuration specifies the type of summary. There are several built in
         * summary types. These call underlying methods on the store:
         *
         *  - {@link Ext.data.Store#count count}
         *  - {@link Ext.data.Store#sum sum}
         *  - {@link Ext.data.Store#min min}
         *  - {@link Ext.data.Store#max max}
         *  - {@link Ext.data.Store#average average}
         *
         * Any other name is assumed to be the name of a method on the associated
         * {@link Ext.app.ViewController view controller}.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.Summary gridsummary} plugin enabled.
         *
         * @deprecated 6.5 Use {@link #cfg!summary} or {@link #cfg!summaryRenderer} instead.
         */
        summaryType: null,

<span id='Ext-grid-column-Column-cfg-exportSummaryRenderer'>        /**
</span>         * @cfg {Boolean/Function/String} exportSummaryRenderer
         *
         * This config is similar to {@link #exportRenderer} but is applied to summary
         * records.
         */
        exportSummaryRenderer: false,

<span id='Ext-grid-column-Column-cfg-minWidth'>        minWidth: 40,
</span>
<span id='Ext-grid-column-Column-cfg-tpl'>        /**
</span>         * @cfg {String/String[]/Ext.XTemplate} tpl
         * An {@link Ext.XTemplate XTemplate}, or an XTemplate *definition string* to use
         * to process a {@link Ext.data.Model records} data to produce a cell&#39;s rendered
         * value.
         *
         *     @example
         *     Ext.create(&#39;Ext.data.Store&#39;, {
         *         storeId:&#39;employeeStore&#39;,
         *         fields:[&#39;firstname&#39;, &#39;lastname&#39;, &#39;seniority&#39;, &#39;department&#39;],
         *         groupField: &#39;department&#39;,
         *         data:[
         *             { firstname: &quot;Michael&quot;, lastname: &quot;Scott&quot;,   seniority: 7, department: &quot;Management&quot; },
         *             { firstname: &quot;Dwight&quot;,  lastname: &quot;Schrute&quot;, seniority: 2, department: &quot;Sales&quot; },
         *             { firstname: &quot;Jim&quot;,     lastname: &quot;Halpert&quot;, seniority: 3, department: &quot;Sales&quot; },
         *             { firstname: &quot;Kevin&quot;,   lastname: &quot;Malone&quot;,  seniority: 4, department: &quot;Accounting&quot; },
         *             { firstname: &quot;Angela&quot;,  lastname: &quot;Martin&quot;,  seniority: 5, department: &quot;Accounting&quot; }
         *         ]
         *     });
         *
         *     Ext.create(&#39;Ext.grid.Panel&#39;, {
         *         title: &#39;Column Template Demo&#39;,
         *         store: Ext.data.StoreManager.lookup(&#39;employeeStore&#39;),
         *         columns: [{
         *             text: &#39;Full Name&#39;,
         *             tpl: &#39;{firstname} {lastname}&#39;
         *         }, {
         *             text: &#39;Department (Yrs)&#39;,
         *             tpl: &#39;{department} ({seniority})&#39;
         *         }],
         *         height: 200,
         *         width: 300,
         *         renderTo: Ext.getBody()
         *     });
         *
         * This config is only processed if the {@link #cell} type is the default of
         * {@link Ext.grid.cell.Cell gridcell}.
         *
         * **Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
         * to rendering cell content.
         */
        tpl: null,

<span id='Ext-grid-column-Column-cfg-computedWidth'>        /**
</span>         * @cfg {Number} computedWidth
         * The computed width for this column, may come from either
         * {@link #width} or {@link #flex}.
         * @readonly
         */
        computedWidth: null,

<span id='Ext-grid-column-Column-cfg-grouper'>        /**
</span>         * @cfg {Function/String/Object/Ext.util.Grouper} grouper
         * A grouper config object to apply when the standard grouping user interface is
         * is invoked. This option is, for example, available in the column&#39;s header
         * menu.
         *
         * Note that a grouper may also be specified as a function which accepts two
         * records to compare.
         *
         * A `{@link Ext.app.ViewController controller}` method can be used like so:
         *
         *      grouper: &#39;groupMethodName&#39;
         *
         * This is different then a `sorter` in that the `grouper` method is used to
         * set the {@link Ext.util.Grouper#cfg!groupFn groupFn}. This string returned
         * by this method is used to determine group membership. To specify both the
         * `grpoupFn` and the `sorterFn`:
         *
         *      grouper: {
         *          groupFn: &#39;groupMethodName&#39;
         *          sorterFn: &#39;sorterMethodName
         *      }
         *
         * @since 6.5.0
         */
        grouper: {
            lazy: true,
            $value: null
        },

<span id='Ext-grid-column-Column-cfg-groupHeaderTpl'>        /**
</span>         * @cfg {String/String[]/Ext.XTemplate} groupHeaderTpl
         * This config allows a column to replace the default template supplied by the
         * grid&#39;s {@link Ext.grid.RowHeader#tpl groupHeader.tpl}.
         *
         * @since 6.5.0
         */
        groupHeaderTpl: null,

<span id='Ext-grid-column-Column-cfg-sorter'>        /**
</span>         * @cfg {Function/String/Object/Ext.util.Sorter} sorter
         * A sorter config object to apply when the standard sort user interface is
         * is invoked. This is usually clicking this column header, but there are also
         * menu options to sort ascending or descending.
         *
         * Note that a sorter may also be specified as a function which accepts two
         * records to compare.
         *
         * A `{@link Ext.app.ViewController controller}` method can be used like so:
         *
         *      sorter: &#39;sorterMethodName&#39;
         *
         * Or more explicitly:
         *
         *      sorter: {
         *          sorterFn: &#39;sorterMethodName&#39;
         *      }
         *
         * By default sorting is based on the `dataIndex` but this can be adjusted
         * like so:
         *
         *      sorter: {
         *          property: &#39;otherProperty&#39;
         *      }
         *
         * @since 6.5.0
         */
        sorter: {
            lazy: true,
            $value: true
        },

<span id='Ext-grid-column-Column-cfg-scratchCell'>        /**
</span>         * @cfg {Ext.grid.cell.Cell/Object} scratchCell
         * @since 6.5.0
         * @private
         */
        scratchCell: {
            lazy: true,
            $value: true
        },

<span id='Ext-grid-column-Column-cfg-menu'>        /**
</span>         * @cfg {Ext.menu.Menu/Object} menu
         * An optional menu configuration object which is merged with the grid&#39;s
         * {@link #cfg!columnMenu} to create this column&#39;s header menu. This can be set
         * to `null` to remove the menu from this column. To dynamically change whether
         * the menu should be enabled or not use the `menuDisabled` config.
         *
         * The grid&#39;s {@link Ext.grid.Grid#cfg!columnMenu} provides the sort items, this
         * config can be used to add column-specific menu items or override aspects of
         * the common items.
         * @since 6.5.0
         */
        menu: {
            lazy: true,
            $value: {}
        },

<span id='Ext-grid-column-Column-cfg-menuDisabled'>        /**
</span>         * @cfg {Boolean} [menuDisabled=false]
         * Set to `true` to disable this column&#39;s `menu` containing sort/hide options.
         * This can be useful if the menu will be dynamically available since setting
         * `menu` to `null` will eliminate the menu making dynamic changes to its
         * availability more expensive.
         * @since 6.5.0
         */
        menuDisabled: null,

<span id='Ext-grid-column-Column-cfg-hideShowMenuItem'>        /**
</span>         * @cfg {Ext.menu.CheckItem/Object} hideShowMenuItem
         * The {@link Ext.menu.CheckItem menu item} to be used by the owning grid&#39;s
         * header menu to hide or show this column.
         * @since 6.5.0
         * @private
         */
        hideShowMenuItem: {
            lazy: true,
            $value: {
                xtype: &#39;menucheckitem&#39;
            }
        }
    },

<span id='Ext-grid-column-Column-cfg-toolDefaults'>    toolDefaults: {
</span>        ui: &#39;gridcolumn&#39;,
        zone: &#39;tail&#39;
    },

<span id='Ext-grid-column-Column-property-toolAnchorName'>    toolAnchorName: &#39;titleWrapElement&#39;,
</span>
<span id='Ext-grid-column-Column-property-dockTools'>    dockTools: false,
</span>
<span id='Ext-grid-column-Column-cfg-scrollable'>    scrollable: false,
</span>
<span id='Ext-grid-column-Column-cfg-docked'>    docked: null,
</span>
<span id='Ext-grid-column-Column-property-sortState'>    sortState: null,
</span>
<span id='Ext-grid-column-Column-property-ariaSortStates'>    // These are not readable descriptions; the values go in the aria-sort attribute.
</span>    ariaSortStates: {
        ASC: &#39;ascending&#39;,
        DESC: &#39;descending&#39;
    },

<span id='Ext-grid-column-Column-property-inheritUi'>    inheritUi: true,
</span>
<span id='Ext-grid-column-Column-property-classCls'>    classCls: Ext.baseCSSPrefix + &#39;gridcolumn&#39;,
</span><span id='Ext-grid-column-Column-property-sortedCls'>    sortedCls: Ext.baseCSSPrefix + &#39;sorted&#39;,
</span><span id='Ext-grid-column-Column-property-secondarySortCls'>    secondarySortCls : Ext.baseCSSPrefix + &#39;secondary-sort&#39;,
</span><span id='Ext-grid-column-Column-property-auxSortCls'>    auxSortCls : Ext.baseCSSPrefix + &#39;aux-sort&#39;,
</span><span id='Ext-grid-column-Column-property-resizableCls'>    resizableCls: Ext.baseCSSPrefix + &#39;resizable&#39;,
</span><span id='Ext-grid-column-Column-property-groupCls'>    groupCls: Ext.baseCSSPrefix + &#39;group&#39;,
</span><span id='Ext-grid-column-Column-property-leafCls'>    leafCls: Ext.baseCSSPrefix + &#39;leaf&#39;,
</span><span id='Ext-grid-column-Column-property-menuOpenCls'>    menuOpenCls: Ext.baseCSSPrefix + &#39;menu-open&#39;,
</span><span id='Ext-grid-column-Column-property-alignCls'>    alignCls: {
</span>        left: Ext.baseCSSPrefix + &#39;align-left&#39;,
        center: Ext.baseCSSPrefix + &#39;align-center&#39;,
        right: Ext.baseCSSPrefix + &#39;align-right&#39;
    },

<span id='Ext-grid-Grid-event-columnmenucreated'>    /**
</span>     * @event columnmenucreated
     * @member Ext.grid.Grid
     * Fired when a column first creates its column menu. This is to allow plugins
     * to access and manipulate the column menu.
     *
     * There will be the two sort items, and a column hide/show item with a child menu of
     * checkboxes. After this, developers may add custom enu items.
     *
     * Menu items may be configured with a `weight` config, and those with the lowest weight
     * gravitate to the top.
     *
     * The sort ascending, sort descending, and hide columns items have weight -3, -2, and -1
     * @param {Ext.grid.Grid} grid This Grid
     * @param {Ext.grid.Column} column The column creating the menu
     * @param {Ext.menu.Menu} menu The column&#39;s new menu
     */

    constructor: function (config) {
        var me = this,
            isHeaderGroup, menu;

        // If we are configured or prototyped as a HeaderGroup
        // TODO - move to updater (me.columns won&#39;t work in all cases)
        if (config.columns || me.columns) {
            isHeaderGroup = me.isHeaderGroup = true;
        } else {
            me.isLeafHeader = true;
        }

        me.callParent([config]);

        me.addCls(isHeaderGroup ? me.groupCls : me.leafCls);

        menu = me.getConfig(&#39;menu&#39;, /*peek=*/true);
        if (!menu &amp;&amp; me.getMenuDisabled() === null) {
            me.setMenuDisabled(true);
        }
    },

<span id='Ext-grid-column-Column-method-getTemplate'>    getTemplate: function () {
</span>        var me = this,
            beforeTitleTemplate = me.beforeTitleTemplate,
            afterTitleTemplate = me.afterTitleTemplate,
            titleTpl = [];

        // Hook for subclasses to insert extra elements
        if (beforeTitleTemplate) {
            titleTpl.push.apply(titleTpl, beforeTitleTemplate);
        }

        titleTpl.push({
            reference: &#39;titleElement&#39;,
            className: Ext.baseCSSPrefix + &#39;title-el&#39;,
            children: [{
                reference: &#39;textElement&#39;,
                className: Ext.baseCSSPrefix + &#39;text-el&#39;,
                &quot;data-qoverflow&quot;: true
            }, {
                reference: &#39;sortIconElement&#39;,
                cls: Ext.baseCSSPrefix + &#39;sort-icon-el &#39; +
                Ext.baseCSSPrefix + &#39;font-icon&#39;
            }]
        });

        // Hook for subclasses to insert extra elements
        if (afterTitleTemplate) {
            titleTpl.push.apply(titleTpl, afterTitleTemplate);
        }

        return [{
            reference: &#39;headerElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;header-el&#39;,
            children: [{
                reference: &#39;titleWrapElement&#39;,
                cls: Ext.baseCSSPrefix + &#39;title-wrap-el&#39;,
                uiCls: &#39;title-wrap-el&#39;,
                children: titleTpl
            }, {
                reference: &#39;resizerElement&#39;,
                cls: Ext.baseCSSPrefix + &#39;resizer-el &#39; +
                     Ext.baseCSSPrefix + &#39;item-no-tap&#39;
            }, {
                reference: &#39;triggerElement&#39;,
                cls: Ext.baseCSSPrefix + &#39;trigger-el &#39; +
                     Ext.baseCSSPrefix + &#39;font-icon &#39; +
                     Ext.baseCSSPrefix + &#39;item-no-tap&#39;
            }]
        }, {
            reference: &#39;bodyElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;body-el&#39;,
            uiCls: &#39;body-el&#39;
        }];
    },

<span id='Ext-grid-column-Column-method-initialize'>    initialize: function () {
</span>        var me = this;

        if (me.isLeafHeader &amp;&amp; !me.getWidth() &amp;&amp; me.getFlex() == null) {
            me.setWidth(me.getDefaultWidth());
        }

        me.callParent();

        me.element.on({
            tap: &#39;onColumnTap&#39;,
            longpress: &#39;onColumnLongPress&#39;,
            scope: this
        });
        me.triggerElement.on({
            tap: &#39;onTriggerTap&#39;,
            scope: this
        });
        me.resizerElement.on({
            tap: &#39;onResizerTap&#39;,
            scope: this
        });

        if (me.isHeaderGroup) {
            me.on({
                add: &#39;doVisibilityCheck&#39;,
                remove: &#39;doVisibilityCheck&#39;,
                show: &#39;onColumnShow&#39;,
                hide: &#39;onColumnHide&#39;,
                move: &#39;onColumnMove&#39;,
                delegate: &#39;&gt; column&#39;,
                scope: me
            });

            me.on({
                show: &#39;onShow&#39;,
                scope: me
            });
        }
    },

<span id='Ext-grid-column-Column-method-doDestroy'>    doDestroy: function () {
</span>        var me = this;

        me.destroyMembers(&#39;editor&#39;, &#39;resizeListener&#39;, &#39;menu&#39;, &#39;hideShowMenuItem&#39;, &#39;childColumnsMenu&#39;);

        me.setScratchCell(null);

        me.mixins.toolable.doDestroy.call(me);

        me.callParent();
    },

<span id='Ext-grid-column-Column-method-onAdded'>    onAdded: function(parent, instanced) {
</span>        this.visibleIndex = null;
        this.callParent([parent, instanced]);
    },

<span id='Ext-grid-column-Column-method-getVisibleIndex'>    /**
</span>     * Returns the index of this column in the list of *visible* columns only if this column is a base level Column. If it
     * is a group column, it returns `false`.
     * @return {Number}
     */
    getVisibleIndex: function() {
        // Note that the visibleIndex property is assigned by the owning HeaderContainer
        // when assembling the visible column set for the view.
        var visibleIndex = this.visibleIndex,
            rootHeaders;

        if (visibleIndex == null) {
            if (this.isHeaderGroup) {
                visibleIndex = false;
            }
            else {
                rootHeaders = this.getRootHeaderCt();

                if (rootHeaders) {
                    visibleIndex = rootHeaders.indexOfLeaf(this);
                }
            }

            this.visibleIndex = visibleIndex;
        }

        return visibleIndex;
    },

<span id='Ext-grid-column-Column-property-_columnScopeRe'>    _columnScopeRe: /^column\./,
</span><span id='Ext-grid-column-Column-property-_gridScopeRe'>    _gridScopeRe: /^grid\./,
</span>
<span id='Ext-grid-column-Column-method-applyMenu'>    applyMenu: function (menu) {
</span>        var me = this,
            grid = me.getGrid(),
            columnScopeRe = me._columnScopeRe,
            gridScopeRe = me._gridScopeRe,
            extraItems, gridColumnMenu, i, item, items, s;

        Ext.destroy(me.sortChangeListener);

        // Allow menu:null to rid the column of all menus... so only merge in the
        // grid&#39;s column menu if we have a non-null menu
        if (menu &amp;&amp; !menu.isMenu) {
            if (Ext.isArray(menu)) {
                extraItems = menu;
                menu = null;
            }
            else if (!menu.items) {
                menu = {
                    items: menu
                };
            }

            if (!(gridColumnMenu = grid.getColumnMenu())) {
                // if menu was an array it is now null, so just make an empty {}
                menu = menu ? Ext.clone(menu) : {};
            }
            else {
                gridColumnMenu = Ext.clone(gridColumnMenu);
                menu = menu ? Ext.merge(gridColumnMenu, menu) : gridColumnMenu;
            }

            menu.ownerCmp = me;

            menu = Ext.create(menu);

            // This column is informed about group changes
            me.sortChangeListener = menu.on({
                groupchange: &#39;onColumnMenuGroupChange&#39;,
                scope: me
            });

            // We cannot use defaultListenerScope to map handlers in our menu to
            // ourselves because user views would then be blocked from doing so to
            // items they may have added to the same menu.
            //
            // Our trick is to encode special scopes in the handler names and see
            // if they have survived until now. It is possible the user has set
            // the handler to something else...

            for (items = menu.getItems().items, i = items &amp;&amp; items.length; i-- &gt; 0; ) {
                item = items[i];

                if (columnScopeRe.test(s = item.getHandler() || &#39;&#39;)) {
                    item.setHandler(s.substr(7));  // remove &quot;column.&quot;
                    item.scope = me;
                }
                else if (gridScopeRe.test(s)) {
                    item.setHandler(s.substr(5));  // remove &quot;grid.&quot;
                    item.scope = grid;
                }
                else if (item.isMenuCheckItem) {
                    if (columnScopeRe.test(s = item.getCheckHandler() || &#39;&#39;)) {
                        item.setCheckHandler(s.substr(7));
                        item.scope = me;
                    }
                    else if (gridScopeRe.test(s)) {
                        item.setCheckHandler(s.substr(5));
                        item.scope = grid;
                    }
                }
            }

            if (extraItems) {
                menu.add(extraItems);
            }

            grid.fireEvent(&#39;columnmenucreated&#39;, grid, me, menu);
        }

        return menu;
    },

<span id='Ext-grid-column-Column-method-updateMenu'>    updateMenu: function (menu, oldMenu) {
</span>        if (oldMenu) {
            oldMenu.destroy();
        }
    },

<span id='Ext-grid-column-Column-method-beforeShowMenu'>    beforeShowMenu: function (menu) {
</span>        var me = this,
            store = me.getGrid().getStore(),
            isGrouped = store &amp;&amp; !!store.getGrouper(),
            groupByThis = menu.getComponent(&#39;groupByThis&#39;),
            showInGroups = menu.getComponent(&#39;showInGroups&#39;),
            sortAsc = menu.getComponent(&#39;sortAsc&#39;),
            sortDesc = menu.getComponent(&#39;sortDesc&#39;);

        sortAsc.setDisabled(!store);
        sortDesc.setDisabled(!store);

        // We have no store yet, we can&#39;t group or ungroup
        if (!store) {
            groupByThis.setHidden(true);
            showInGroups.setHidden(true);
            return;
        }

        // Ensure the checked state of the ascending and descending menu items
        // matches the reality of the Store&#39;s sorters.
        //
        // We are syncing the menu state with the reality of the store.
        // Ensure its state change doesn&#39;t drive the store state
        // by suspending the groupchange event.
        menu.suspendEvent(&#39;groupchange&#39;);
        if (sortAsc) {
            me.syncMenuItemState(sortAsc);
        }
        if (sortDesc) {
            me.syncMenuItemState(sortDesc);
        }

        if (groupByThis) {
            groupByThis.setHidden(!(me.canGroup() &amp;&amp; !store.isTreeStore));
        }
        menu.resumeEvent(&#39;groupchange&#39;);

        if (showInGroups) {
            // A TreeStore is never grouped
            showInGroups.setHidden(store.isTreeStore);
            // Disable the &quot;Show in groups&quot; options if we&#39;re not already shown in groups
            showInGroups.setChecked(isGrouped);
            showInGroups.setDisabled(!isGrouped);
        }
    },

<span id='Ext-grid-column-Column-method-showMenu'>    showMenu: function () {
</span>        var me = this,
            menu = !me.getMenuDisabled() &amp;&amp; me.getMenu(),
            menuOpenCls = me.menuOpenCls,
            columnsMenu, grid;

        // Only try if the menu is not disabled, and there *is* a menu
        if (menu) {
            grid = me.getGrid();
            columnsMenu = grid.getColumnsMenuItem();
            menu.add(columnsMenu);

            if (me.beforeShowMenu(menu) !== false &amp;&amp;
                    grid.beforeShowColumnMenu(me, menu) !== false) {
                menu.showBy(me.triggerElement);

                // Add menu open class to show the trigger element while the menu is open
                me.addCls(menuOpenCls);

                menu.on({
                    single: true,
                    hide: function () {
                        if (!(me.destroyed || me.destroying)) {
                            me.removeCls(menuOpenCls);
                            menu.remove(columnsMenu, /*destroy=*/false);
                        }
                    }
                });
            }
        }
    },

<span id='Ext-grid-column-Column-method-getCells'>    getCells: function () {
</span>        var cells = [],
            rows = this.getGrid().items.items,
            len = rows.length,
            i, row;

        for (i = 0; i &lt; len; ++i) {
            row = rows[i];
            if (row.isGridRow) {
                cells.push(row.getCellByColumn(this));
            }
        }

        return cells;
    },

<span id='Ext-grid-column-Column-method-getColumnForField'>    getColumnForField: function (fieldName) {
</span>        if (fieldName === this.getDataIndex()) {
            return this;
        }

        return this.callParent([ fieldName ]);
    },

<span id='Ext-grid-column-Column-method-isHideable'>    /**
</span>     * Determines whether the UI should be allowed to offer an option to hide this column.
     *
     * A column may *not* be hidden if to do so would leave the grid with no visible columns.
     *
     * This is used to determine the enabled/disabled state of header hide menu items.
     */
    isHideable: function() {
        var menuOfferingColumns = [];

        // Collect menu offering columns so that we can assess our hideability.
        // Cannot use CQ because we need to use getConfig with peek flag to
        // check whether there&#39;s a menu without instantiating it.
        this.getRootHeaderCt().visitPreOrder(&#39;gridcolumn:not([hidden])&#39;, function(col) {
            if (!col.getMenuDisabled() &amp;&amp; col.getConfig(&#39;menu&#39;, true)) {
                menuOfferingColumns.push(col);
            }
        });

        return menuOfferingColumns.length &gt; 1 || menuOfferingColumns[0] !== this;
    },

<span id='Ext-grid-column-Column-method-applyTpl'>    applyTpl: function (tpl) {
</span>        return Ext.XTemplate.get(tpl);
    },

<span id='Ext-grid-column-Column-method-applyAlign'>    applyAlign: function(align, oldAlign) {
</span>        if (align == null) {
            align = this.isHeaderGroup ? &#39;center&#39; : &#39;left&#39;;
        }

        return align;
    },

<span id='Ext-grid-column-Column-method-updateAlign'>    updateAlign: function (align, oldAlign) {
</span>        var me = this,
            alignCls = me.alignCls;

        if (oldAlign) {
            me.removeCls(alignCls[oldAlign]);
        }

        if (align) {
            //&lt;debug&gt;
            if (!alignCls[align]) {
                Ext.raise(&quot;Invalid value for align: &#39;&quot; + align + &quot;&#39;&quot;);
            }
            //&lt;/debug&gt;
            me.addCls(alignCls[align]);
        }

        me.syncToolableAlign();
    },

<span id='Ext-grid-column-Column-method-updateMenuDisabled'>    updateMenuDisabled: function (menuDisabled) {
</span>        if (this.triggerElement) {
            this.triggerElement.setVisible(!menuDisabled);
        }
    },

<span id='Ext-grid-column-Column-method-onColumnTap'>    onColumnTap: function (e) {
</span>        var me = this,
            grid = me.getGrid(),
            selModel = grid.getSelectable(),
            store = grid.getStore(),
            sorters = store &amp;&amp; store.getSorters(true),
            sorter = store &amp;&amp; me.pickSorter(),
            sorterIndex = sorter ? sorters.indexOf(sorter) : -1,
            isSorted = sorter &amp;&amp; (sorterIndex !== -1 || sorter === store.getGrouper());

        // Tapping on the trigger or resizer must not sort the column and
        // neither should tapping on any components (e.g. tools) contained
        // in the column.
        if (Ext.Component.from(e) !== me ||
            e.getTarget(&#39;.&#39; + Ext.baseCSSPrefix + &#39;item-no-tap&#39;, me)) {
            return;
        }

        // Column tap sorts if we are sortable, and the selection model
        // is not selecting columns
        if (store &amp;&amp; me.isSortable() &amp;&amp; (!selModel || !selModel.getColumns())) {
            // Special case that our sorter is the grouper
            if (sorter.isGrouper) {
                sorter.toggle();
                store.group(sorter);
            }
            // If we are already the primary sorter
            // then just toggle through the three states
            else if (sorterIndex === 0) {
                me.toggleSortState();
            }
            // We must be a secondary or auxilliary in a multi column sort grid,
            // or unsorted now.
            else {
                // We&#39;re secondary or auxilliary, bring top top of sorter stack
                if (isSorted) {
                    store.sort(sorter, &#39;prepend&#39;);
                }
                // Our sorter is unused, go primary, ascending
                else {
                    me.sort(&#39;ASC&#39;);
                }
            }
        }

        return me.fireEvent(&#39;tap&#39;, me, e);
    },

<span id='Ext-grid-column-Column-method-onTriggerTap'>    onTriggerTap: function (e) {
</span>        this.fireEvent(&#39;triggertap&#39;, this, e);
    },

<span id='Ext-grid-column-Column-method-onResizerTap'>    onResizerTap: function (e) {
</span>        // If they tapped on the resizer without dragging, interpret that as a tap
        // on the trigger, if it&#39;s in the correct region.
        if (e.getPoint().isContainedBy(this.triggerElement.getRegion())) {
            this.fireEvent(&#39;triggertap&#39;, this, e);
        }
    },

<span id='Ext-grid-column-Column-method-onColumnLongPress'>    onColumnLongPress: function (e) {
</span>        this.fireEvent(&#39;longpress&#39;, this, e);
    },

<span id='Ext-grid-column-Column-method-onGroupByThis'>    onGroupByThis: function () {
</span>        var me = this,
            grid = me.getGrid(),
            grouper = me.getGrouper(),
            store = grid.getStore(),
            dataIndex;

        if (!grouper) {
            dataIndex = me.getDataIndex();

            if (dataIndex != null) {
                me.setGrouper({
                    property: dataIndex
                });

                grouper = me.getGrouper();
            }
        }

        if (grouper) {
            store.setGrouper(grouper);
        }
        grid.setGrouped(true);
    },

<span id='Ext-grid-column-Column-method-onColumnMenuGroupChange'>    /**
</span>     * @private
     * Called as a groupchange handler on the header menu to either set the direction, or
     * remove the sorter.
     */
    onColumnMenuGroupChange: function (menu, groupName, value) {
        if (groupName === &#39;sortDir&#39;) {
            this.setSortDirection(value);
        }
    },

<span id='Ext-grid-column-Column-method-getSortDirection'>    getSortDirection: function () {
</span>        var sorter = this.pickSorter();

        return sorter &amp;&amp; sorter.getDirection();
    },

<span id='Ext-grid-column-Column-method-setSortDirection'>    setSortDirection: function (direction) {
</span>        var me = this,
            grid = me.getGrid(),
            store = grid.getStore(),
            sorter = me.pickSorter(),
            sorters = store.getSorters(true),
            isSorted = sorter &amp;&amp; (sorters.contains(sorter) || sorter.isGrouper);

        // Toggling to checked.
        if (direction) {
            if (isSorted) {
                if (sorter.getDirection() !== direction) {
                    sorter.setDirection(direction);

                    if (sorter.isGrouper) {
                        store.group(sorter);
                    } else {
                        sorters.beginUpdate();
                        sorters.endUpdate();
                    }
                }
            }
            // Either the sorter is not applied, or it&#39;s the first time and there&#39;s no sorter.
            // Sort by direction as primary
            else {
                return me.sort(direction);
            }
        }
        // Toggled to clear.
        // If we own a sorter, and its in our direction, and it&#39;s applied to the store
        // then remove it.
        else if (sorter) {
            sorters.remove(sorter);
        }

        // A locally sorted store will not refresh in response to having a sorter
        // removed, so we must sync the column header arrows now.
        // AbstractStore#onSorterEndUpdate will however always fire the sort event
        // which is what Grid uses to trigger a HeaderContainer sort state sync
        if (!store.getRemoteSort()) {
            me.getRootHeaderCt().setSortState();
        }
    },

<span id='Ext-grid-column-Column-method-syncMenuItemState'>    syncMenuItemState: function (menuItem) {
</span>        if (menuItem) {
            var me = this,
                sortable = me.isSortable(),
                store = me.getGrid().getStore(),
                sorter = me.pickSorter(),
                isSorted = sorter &amp;&amp; (store.getSorters().contains(sorter) || sorter.isGrouper);

            menuItem.setDisabled(!sortable);
            menuItem.setChecked(sortable &amp;&amp; isSorted &amp;&amp; sorter.getDirection() === menuItem.getValue());
        }
    },

<span id='Ext-grid-column-Column-method-onToggleShowInGroups'>    onToggleShowInGroups: function (menuItem) {
</span>        var grid = this.getGrid(),
            store = grid.getStore();

        grid.setGrouped(false);
        store.setGrouper(null);
    },

<span id='Ext-grid-column-Column-method-updateResizable'>    updateResizable: function (resizable) {
</span>        var me = this,
            widthed = me.getWidth() != null,
            flexed = me.getFlex() != null;

        // Column only drag-resizable if it&#39;s widthed, flexed, or a leaf.
        // If it&#39;s shrinkwrapping child columns then the child columns must be resized.
        me.toggleCls(me.resizableCls, !!(me.getResizable() &amp;&amp; (widthed || flexed ||
            me.isLeafHeader)));
    },

<span id='Ext-grid-column-Column-method-updateText'>    updateText: function (text) {
</span>        this.setHtml(text || &#39;\xa0&#39;);
    },

<span id='Ext-grid-column-Column-method-onResize'>    onResize: function () {
</span>        if (!this.isHidden(true)) {
            // Update the resizability of this column based on *how* it&#39;s just been sized.
            // If we are shrinkwrapping, we are not drag-resizable.
            this.updateResizable(this.getResizable());

            // Computed with needs to be exact so that sub-pixel changes are
            // not rejected by the config system because scrollbars may
            // depend upon the *exact* width of the cells in the view.
            this.measureWidth();
        }
    },

<span id='Ext-grid-column-Column-method-getComputedWidth'>    getComputedWidth: function () {
</span>        return this.isVisible(true) ? this._computedWidth : 0;
    },

<span id='Ext-grid-column-Column-method-updateColumns'>    updateColumns: function (columns) {
</span>        this.getItems();
        this.add(columns);
    },

<span id='Ext-grid-column-Column-method-measureWidth'>    measureWidth: function () {
</span>        // Computed width must be a real. exact pixel width.
        // It cannot be em or rem etc because it is used to size owned cells
        // and different styles and fonts may be applied to cells.
        var width = this.el.measure(&#39;w&#39;);

        this.setComputedWidth(width);

        return width;
    },

<span id='Ext-grid-column-Column-method-updateComputedWidth'>    updateComputedWidth: function (value, oldValue) {
</span>        var me = this,
            rootHeaderCt = !me.isConfiguring &amp;&amp; me.getRootHeaderCt();

        // This is how grid&#39;s resize their cells in response. Not through events.
        // Width change events arrive asynchronously through resize listeners
        // and that would cause janky grid resizes.
        //
        // By informing the grid, it can force all flexed columns to republish
        // their computed widths, and correctly update all cells in one pass.
        if (rootHeaderCt) {
            // This updates the cells.
            rootHeaderCt.onColumnComputedWidthChange(me, value);

            // Fire the event after cells have been resized
            me.fireEvent(&#39;columnresize&#39;, me, value, oldValue);
        }
    },

<span id='Ext-grid-column-Column-method-updateDataIndex'>    updateDataIndex: function (dataIndex) {
</span>        var sorter;

        if (!this.isConfiguring) {
            sorter = this.pickSorter();

            if (sorter) {
                this.setSorter(null);
            }
        }
    },

<span id='Ext-grid-column-Column-method-applyGroupHeaderTpl'>    applyGroupHeaderTpl: function (tpl) {
</span>        return Ext.XTemplate.get(tpl);
    },

<span id='Ext-grid-column-Column-method-updateGroupHeaderTpl'>    updateGroupHeaderTpl: function (tpl) {
</span>        var grouper = this.grouper;

        if (grouper) {
            grouper.headerTpl = tpl;
        }
    },

<span id='Ext-grid-column-Column-method-isSortable'>    isSortable: function () {
</span>        var me = this;

        // Only leaf headers are sortable.
        // Only if we are not configured sortable: false.
        // We&#39;re not sortable if there&#39;s no Sorter configured AND we have no dataIndex.
        // HeaderContainer&#39;s sortable config must be honoured dynamically since
        // SelectionModels can change it.
        // And the grid has the final say.
        return me.isLeafHeader &amp;&amp;
            me.getSortable() &amp;&amp;
            (me.pickSorter() || me.getDataIndex()) &amp;&amp;
            me.getRootHeaderCt().getSortable() &amp;&amp;
            me.getGrid().sortableColumns !== false;
    },

<span id='Ext-grid-column-Column-method-applyEditor'>    applyEditor: function (value) {
</span>        if (value &amp;&amp; !value.isInstance) {
            if (typeof(value) === &#39;string&#39;) {
                value = {
                    xtype: value
                };
            }

            if (!value.xtype) {
                value = Ext.apply({
                    xtype: value.field ? &#39;celleditor&#39; : &#39;textfield&#39;
                }, value);
            }

            return Ext.create(value);
        }

        return value;
    },

<span id='Ext-grid-column-Column-method-applyDefaultEditor'>    applyDefaultEditor: function(editor) {
</span>        var dataIndex = this.getDataIndex(),
            model, field;

        if (dataIndex &amp;&amp; !editor.isInstance) {
            // We mutate the config
            editor = Ext.clone(editor);

            // Infer default xtype from data field type
            if (!editor.isInstance &amp;&amp; !editor.xtype) {
                model = this.getGrid().getStore().getModel();
                field = model.getField(dataIndex);

                if (field) {
                    switch (field.type) {
                        case &#39;date&#39;:
                            editor.xtype = &#39;datefield&#39;;
                            break;
                        case &#39;int&#39;:
                        case &#39;integer&#39;:
                            editor.xtype = &#39;numberfield&#39;;
                            editor.decimals = 0;
                            break;
                        case &#39;float&#39;:
                        case &#39;number&#39;:
                            editor.xtype = &#39;numberfield&#39;;
                            break;
                        case &#39;boolean&#39;:
                        case &#39;bool&#39;:
                            editor.xtype = &#39;checkboxfield&#39;;
                            break;
                        default:
                            editor.xtype = &#39;textfield&#39;;
                    }
                } else {
                    editor.xtype = &#39;textfield&#39;;
                }
            }
        }
        return editor;
    },

<span id='Ext-grid-column-Column-method-updateEditor'>    updateEditor: function (editor, oldEditor) {
</span>        // If we are changing editors destroy the last one
        // but if we are changing from a field to a cell editor make sure we do not destroy
        // the field that is now a child of the cell editor
        if (oldEditor &amp;&amp; (!editor || (editor.isCellEditor &amp;&amp; editor.getField() !== oldEditor))) {
            oldEditor.destroy();
        }
    },

<span id='Ext-grid-column-Column-method-applyFormatter'>    applyFormatter: function (format) {
</span>        var me = this,
            fmt = format,
            parser;

        if (fmt) {
            parser = Ext.app.bind.Parser.fly(fmt);
            fmt = parser.compileFormat();
            parser.release();

            return function (v) {
                return fmt(v, me.getScope() || me.resolveListenerScope());
            };
        }

        return fmt;
    },

<span id='Ext-grid-column-Column-method-applySummaryFormatter'>    applySummaryFormatter: function (format) {
</span>        var me = this,
            fmt = format,
            parser;

        if (fmt) {
            parser = Ext.app.bind.Parser.fly(fmt);
            fmt = parser.compileFormat();
            parser.release();
            return function (v) {
                return fmt(v, me.getScope() || me.resolveListenerScope());
            };
        }

        return fmt;
    },

<span id='Ext-grid-column-Column-method-applyGrouper'>    applyGrouper: function (grouper) {
</span>        var me = this,
            cfg = grouper;

        if (cfg &amp;&amp; !cfg.isInstance) {
            if (typeof cfg === &#39;string&#39;) {
                cfg = {
                    groupFn: cfg
                };
            } else {
                cfg = Ext.apply({}, cfg);
            }

            if (typeof cfg.groupFn === &#39;string&#39;) {
                cfg = me.scopeReplacer(cfg, grouper, &#39;groupFn&#39;, &#39;setGroupFn&#39;);
            }

            if (typeof cfg.sorterFn === &#39;string&#39;) {
                cfg = me.scopeReplacer(cfg, grouper, &#39;sorterFn&#39;, &#39;setSorterFn&#39;);
            }

            grouper = new Ext.util.Grouper(cfg);
        }

        // The owner/headerTpl expandos on our grouper are picked up by the ItemHeader
        // as a means to override the list&#39;s groupHeaderTpl...
        if (grouper) {
            grouper.owner = me.getGrid();
            grouper.headerTpl = me.getGroupHeaderTpl();
        }

        // So folks can easily pick this up w/o calling getGrouper which will trigger
        // its creation.
        return grouper;
    },

<span id='Ext-grid-column-Column-method-updateGrouper'>    updateGrouper: function (grouper, oldGrouper) {
</span>        var store = this.getGrid().getStore();

        if (store &amp;&amp; oldGrouper) {
            if (oldGrouper === store.getGrouper()) {
                store.setGrouper(grouper);
            }
        }

        this.grouper = grouper;
    },

<span id='Ext-grid-column-Column-method-applySorter'>    applySorter: function (sorter) {
</span>        var me = this,
            cfg = sorter,
            sortProperty;

        if (cfg &amp;&amp; !cfg.isInstance) {
            // The default value is true to indicate use the dataIndex
            if (cfg === true) {
                sortProperty = me.getSortParam();
                if (!sortProperty) {
                    return null;
                }

                cfg = {
                    property: sortProperty,
                    direction: &#39;ASC&#39;
                };
            } else {
                if (typeof cfg === &#39;string&#39;) {
                    cfg = {
                        sorterFn: cfg
                    };
                }

                if (typeof cfg.sorterFn === &#39;string&#39;) {
                    cfg = me.scopeReplacer(cfg, sorter, &#39;sorterFn&#39;, &#39;setSorterFn&#39;);
                }
            }

            sorter = new Ext.util.Sorter(cfg);
        }

        if (sorter) {
            sorter.owner = me.getGrid();
        }

        return sorter;
    },

<span id='Ext-grid-column-Column-method-updateSorter'>    updateSorter: function (sorter, oldSorter) {
</span>        var store = this.getGrid().getStore(),
            sorters = store ? store.getSorters() : null,
            at;

        // If our previous sorter is in the store, replace it with the new one or
        // just remove it if we don&#39;t have one.
        if (sorters) {
            if (oldSorter &amp;&amp; (at = sorters.indexOf(oldSorter)) &gt; -1) {
                if (sorter) {
                    sorters.splice(at, 1, sorter);
                } else {
                    sorters.remove(oldSorter);
                }
            }
        }

        // So folks can easily pick this up w/o calling getSorter which will trigger
        // its creation.
        this.sorter = sorter;
    },

<span id='Ext-grid-column-Column-method-pickSorter'>    pickSorter: function() {
</span>        var me = this,
            store = me.getGrid().getStore(),
            result;

        // Must always use the grouper if our dataIndex is the store&#39;s groupField.
        // We have to test dynamically in the getter because of possible store changes
        if (store.isGrouped() &amp;&amp; store.getGroupField() === me.getDataIndex()) {
            result = me.getGrouper() || store.getGrouper();

            // The sort state is always the direction of the grouper
            me.sortState = result.getDirection();
        }
        else {
            result = me.getSorter();
        }

        return result;
    },

<span id='Ext-grid-column-Column-method-applyHideShowMenuItem'>    applyHideShowMenuItem: function (config, existing) {
</span>        return Ext.updateWidget(existing, config, this, &#39;createHideShowMenuItem&#39;);
    },

<span id='Ext-grid-column-Column-method-createHideShowMenuItem'>    createHideShowMenuItem: function(defaults) {
</span>        return Ext.apply({
            text: this.getText(),
            checked: !this.getHidden(),
            column: this
        }, defaults);
    },

<span id='Ext-grid-column-Column-method-getHideShowMenuItem'>    getHideShowMenuItem: function(deep) {
</span>        var me = this,
            result = me.callParent(),
            items = me.items.items,
            len = items.length,
            childItems = [],
            childColumnsMenu = me.childColumnsMenu,
            i;

        // If we&#39;re a header group, we offer our hideable child columns
        // in a submenu.
        if (me.isHeaderGroup &amp;&amp; deep !== false) {
            if (!childColumnsMenu) {
                result.setMenu({});
                me.childColumnsMenu = childColumnsMenu = result.getMenu();
            }
            if (!childColumnsMenu.items.length || me.rebuildChildColumnsMenu) {
                for (i = 0; i &lt; len; i++) {
                    if (items[i].getHideable()) {
                        childItems.push(items[i].getHideShowMenuItem());
                    }
                }
                childColumnsMenu.removeAll(false);
                childColumnsMenu.add(childItems);
            }
        }

        // Ensure we&#39;re enabled/disabled correctly on first show
        result[&#39;set&#39; + (result.getMenu() ? &#39;CheckChange&#39; : &#39;&#39;) + &#39;Disabled&#39;](!me.isHideable());

        return result;
    },

<span id='Ext-grid-column-Column-method-getInnerHtmlElement'>    getInnerHtmlElement: function () {
</span>        return this.textElement;
    },

<span id='Ext-grid-column-Column-method-getSortParam'>    /**
</span>     * Returns the parameter to sort upon when sorting this header. By default this returns
     * the dataIndex and will not need to be overridden in most cases.
     * @return {String}
     */
    getSortParam: function () {
        return this.getDataIndex();
    },

<span id='Ext-grid-column-Column-method-applyCell'>    applyCell: function(cell, oldCell) {
</span>        // Allow the cell config object to be reconfigured.
        if (oldCell) {
            cell = Ext.apply(oldCell, cell);
        }
        return cell;
    },

<span id='Ext-grid-column-Column-method-createCell'>    createCell: function (row) {
</span>        var me = this,
            cfg = {
                row: row,
                ownerCmp: row || me,
                column: me,
                width: me.rendered ? (me.getComputedWidth() || me.measureWidth()) : me.getWidth(),
                minWidth: me.getMinWidth()
            },
            align = me.getAlign(),
            cellCfg;

        if (row &amp;&amp; row.isSummaryRow) {
            cellCfg = me.getSummaryCell();

            if (!cellCfg) {
                cellCfg = me.getCell();

                if (cellCfg.xtype === &#39;widgetcell&#39;) {
                    // We don&#39;t default to creating a widgetcell in a summary row, so
                    // fallback to a normal cell
                    cellCfg = Ext.apply({}, cellCfg);
                    cellCfg.xtype = &#39;gridcell&#39;;
                    delete cellCfg.widget;
                }
            }
        }
        else {
            cellCfg = me.getCell();
        }

        if (align) {
            // only put align on the config object if it is not null.  This prevents
            // the column&#39;s default value of null from overriding a value set on the
            // cell&#39;s class definition (e.g. widgetcell)
            cfg.align = align;
        }

        if (row) {
            cfg.hidden = me.isHidden(row.getGrid().getHeaderContainer());
            cfg.record = row.getRecord();

            if (!(cfg.ui = row.getDefaultCellUI())) {
                delete cfg.ui;
            }
        }

        if (typeof cellCfg === &#39;string&#39;) {
            cfg.xtype = cellCfg;
        }
        else {
            Ext.apply(cfg, cellCfg);
        }

        return cfg;
    },

<span id='Ext-grid-column-Column-method-applyScratchCell'>    applyScratchCell: function(cell, oldCell) {
</span>        var me = this;

        if (cell) {
            cell = Ext.create(me.createCell());

            if (!cell.printValue) {
                // If this cell type (widgetcell) cannot print its value, fallback to
                // default gridcell
                Ext.destroy(cell);
                cell = me.createCell();
                cell.xtype = &#39;gridcell&#39;;
                cell = Ext.create(cell);
            }
            // Add the positioned class to make this position:absolute so that it can be
            // added to the document without breaking the layout.
            cell.addCls(me.floatingCls);
        }

        if (oldCell) {
            oldCell.destroy();
        }

        return cell;
    },

<span id='Ext-grid-column-Column-method-printValue'>    printValue: function (value) {
</span>        var me = this,
            rows = me.getGrid().dataItems,
            cell;

        if (rows.length) {
            cell = rows[0].getCellByColumn(me);
        }

        cell = (cell &amp;&amp; cell.printValue) ? cell : me.getScratchCell();

        return cell.printValue(value);
    },

<span id='Ext-grid-column-Column-property-privates'>    privates: {
</span>        // State map for cycling our sortState property
        directionSequence: {
            &quot;null&quot;: &quot;ASC&quot;,
            &quot;ASC&quot;: &quot;DESC&quot;,
            &quot;DESC&quot;: null
        },

        applySummary: function (summary) {
            if (summary) {
                summary = Ext.Factory.dataSummary(summary);
            }

            return summary;
        },

        beginRefresh: function (context) {
            // This is called by our detached cells
            var me = this,
                grid = me.getGrid();

            context = context || {};

            context.column = me;
            context.grid = grid;
            // record = null
            // row = null
            context.store = grid.store;

            return context;
        },

        canGroup: function() {
            return this.getGroupable() &amp;&amp; (this.getDataIndex() || this.getGrouper());
        },

<span id='Ext-grid-column-Column-method-sort'>        /**
</span>         * Sorts by this column&#39;s sorter in the passed direction.
         * @param direction
         * @param mode
         */
        sort: function(direction, mode) {
            var me = this,
                sorter = me.pickSorter(),
                grid = me.getGrid(),
                store = grid.getStore(),
                sorters = store.getSorters();

            if (!me.isSortable()) {
                return;
            }

            // This is the &quot;group by&quot; column - we have to set the grouper and tell it to
            // recalculate. AbstractStore#group just calls its Collection&#39;s updateGrouper
            // if passed a Grouper because *something* in the grouper might have changed,
            // but the config system would reject that as not a change.
            if (sorter.isGrouper) {
                if (sorter.getDirection() !== direction) {
                    sorter.toggle();
                    store.group(sorter);
                }
            }
            // We are moving to a sorted state
            else if (direction) {
                // We have a sorter - set its direction.
                if (sorter) {
                    // Not the primary. We will make it so.
                    // If it&#39;s already the primary, SorterCollection#addSort will toggle it
                    if (sorters.indexOf(sorter) !== 0) {
                        sorter.setDirection(direction);
                    }
                }
                // First time in, create a sorter with required direction
                else {
                    me.setSorter({
                        property: me.getSortParam(),
                        direction: &#39;ASC&#39;
                    });

                    sorter = me.getSorter(); // not pickSorter
                }

                // If the grid is NOT configured with multi column sorting, then specify
                // &quot;replace&quot;. Only if we are doing multi column sorting do we insert it as
                // one of a multi set.
                store.sort(sorter, mode || grid.getMultiColumnSort() ? &#39;multi&#39; : &#39;replace&#39;);
            }
            // We&#39;re moving to an unsorted state
            else {
                if (sorter) {
                    sorters.remove(sorter);

                    // A locally sorted store will not refresh in response to having a
                    // sorter removed, so we must sync the column header arrows now.
                    // AbstractStore#onSorterEndUpdate will however always fire the sort
                    // event which is what Grid uses to trigger a HeaderContainer sort
                    // state sync
                    if (!store.getRemoteSort()) {
                        me.getRootHeaderCt().setSortState();
                    }
                }
            }
        },

<span id='Ext-grid-column-Column-method-toggleSortState'>        /**
</span>         * Called on HeaderTap to toggle the column through three sort states.
         *
         *    Is primary sort?
         *      Yes - Cycle through ASC, DESC, None
         *      No - is sorted?
         *          Yes - Make it primary (leave direction alone)
         *          No - Make it primary ASC
         *
         *  - None -&gt; ASC
         *  - ASC  -&gt; DESC
         *  - DESC -&gt; None
         */
        toggleSortState: function () {
            this.sort(this.directionSequence[this.sortState]);
        },

<span id='Ext-grid-column-Column-method-setSortState'>        /**
</span>         * Sets the column sort state according to the direction of the Sorter passed.
         * @param {Ext.util.Sorter/String} sorter A Sorter, or the direction (`&#39;ASC&#39;` or `&#39;DESC&#39;`) to display in the header.
         */
        setSortState: function (sorter) {
            // Set the UI state to reflect the state of any passed Sorter
            // Called by the grid&#39;s HeaderContainer on view refresh
            var me = this,
                store = me.getGrid().getStore(),
                grouper = store.isGrouped() &amp;&amp; store.getGrouper(),
                oldDirection = me.sortState,
                direction = null,
                sortedCls = me.sortedCls,
                secondarySortCls = me.secondarySortCls,
                auxSortCls = me.auxSortCls,
                ascCls = sortedCls + &#39;-asc&#39;,
                descCls = sortedCls + &#39;-desc&#39;,
                ariaDom = me.ariaEl.dom,
                sortPrioClass = &#39;&#39;,
                changed, index,
                remove = [
                    secondarySortCls,
                    auxSortCls
                ],
                add;

            if (sorter) {
                if (typeof sorter === &#39;string&#39;) {
                    direction = sorter;
                } else {
                    //&lt;debug&gt;
                    if (!sorter.isSorter) {
                        Ext.raise(&#39;Must pass a sorter instance into HeaderContainer#saveState&#39;);
                    }
                    //&lt;/debug&gt;

                    // The Grouper is always primary
                    if (sorter === grouper) {
                        index = 0;
                    }
                    else {
                        index = store.getSorters().indexOf(sorter);
                    }

                    //&lt;debug&gt;
                    if (index === -1) {
                        Ext.raise(&quot;Sorter passed into HeaderContainer#saveState is not used by the grid&#39;s store&quot;);
                    }
                    //&lt;/debug&gt;

                    direction = sorter.getDirection();
                    sortPrioClass = index === 1 ? secondarySortCls : index &gt; 1 ? auxSortCls : &#39;&#39;;
                }
            }

            // Detect if we&#39;ve changed state, then set our state
            changed = direction !== oldDirection;
            me.sortState = direction;

            switch (direction) {
                case &#39;DESC&#39;:
                    add = [sortedCls, descCls, sortPrioClass];
                    remove.push(ascCls);
                    break;

                case &#39;ASC&#39;:
                    add = [sortedCls, ascCls, sortPrioClass];
                    remove.push(descCls);
                    break;

                default:
                    remove.push(sortedCls, ascCls, descCls);
                    break;
            }
            me.replaceCls(remove, add);

            if (ariaDom) {
                if (direction) {
                    ariaDom.setAttribute(&#39;aria-sort&#39;, me.ariaSortStates[direction]);
                }
                else {
                    ariaDom.removeAttribute(&#39;aria-sort&#39;);
                }
            }

            // we only want to fire the event if we have actually sorted
            if (changed) {
                me.fireEvent(&#39;sort&#39;, me, direction, oldDirection);
            }
        },

        getVisibleCount: function () {
            var columns = this.getInnerItems(),
                len = columns.length,
                count = 0,
                i;

            for (i = 0; i &lt; len; ++i) {
                if (columns[i].isHeaderGroup) {
                    count += columns[i].getVisibleCount();
                } else {
                    count += columns[i].isHidden() ? 0 : 1;
                }
            }

            return count;
        },

        onShow: function () {
            var toShow;

            // No visible subcolumns, then show the first child.
            if (!this.getVisibleCount()) {
                toShow = this.getComponent(0);
                if (toShow) {
                    toShow.show();
                }
            }
        },

        doVisibilityCheck: function () {
            var me = this,
                columns = me.getInnerItems(),
                ln = columns.length,
                i, column;

            for (i = 0; i &lt; ln; i++) {
                column = columns[i];

                if (!column.isHidden()) {
                    if (me.isHidden()) {
                        if (me.initialized) {
                            me.show();
                        } else {
                            me.setHidden(false);
                        }
                    }
                    return;
                }
            }

            me.hide();

            // Next time we show our hide/show item, we need to rebuild the submenu
            me.rebuildChildColumnsMenu = true;

            // Update hideable/showable state of column menu items
            me.updateMenuDisabledState();
        },

        onColumnShow: function () {
            var me = this,
                hideShowItem;

            if (me.getVisibleCount() &gt; 0) {
                me.show();
                hideShowItem = me.getHideShowMenuItem(false);
                hideShowItem.setChecked(true);
                hideShowItem.setCheckChangeDisabled(false);
            }

            // Next time we show our hide/show item, we need to rebuild the submenu
            me.rebuildChildColumnsMenu = true;

            // Update hideable/showable state of column menu items
            me.updateMenuDisabledState();
        },

        onColumnHide: function (column) {
            var me = this,
                hideShowItem;

            if (me.getVisibleCount() === 0) {
                me.hide();
                hideShowItem = me.getHideShowMenuItem(false);
                hideShowItem.setChecked(false);
                hideShowItem.setCheckChangeDisabled(true);
            }

            // Next time we show our hide/show item, we need to rebuild the submenu
            me.rebuildChildColumnsMenu = true;

            // Update hideable/showable state of column menu items
            me.updateMenuDisabledState();
        },

        onColumnMove: function(column) {
            // Next time we show our hide/show item, we need to rebuild the submenu
            this.rebuildChildColumnsMenu = true;
        },

        scopeReplacer: function (config, original, prop, setter) {
            var me = this,
                name = config[prop];

            if (typeof name === &#39;string&#39;) {
                prop = prop || &#39;sorterFn&#39;;
                setter = setter || &#39;setSorterFn&#39;;

                if (original === config) {
                    config = Ext.apply({}, config);
                }

                // The goal of this method is to be called only on the first use
                // and then replace itself (using the setter) to direct all future
                // calls to the proper method.
                config[prop] = function () {
                    // NOTE &quot;this&quot; is Sorter or Grouper!
                    var scope = me.resolveListenerScope(),
                        fn = scope &amp;&amp; scope[name],
                        ret = 0;

                    if (fn) {
                        this[setter](fn.bind(scope));

                        ret = fn.apply(scope, arguments);
                    }
                    //&lt;debug&gt;
                    else if (!scope) {
                        Ext.raise(&#39;Cannot resolve scope for column &#39; + me.id);
                    }
                    else {
                        Ext.raise(&#39;No such method &quot;&#39; + name + &#39;&quot; on &#39; + scope.$className);
                    }
                    //&lt;/debug&gt;

                    return ret;
                };
            }

            return config;
        }
    } // privates
});
</pre>
</body>
</html>
