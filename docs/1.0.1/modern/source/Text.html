<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-field-Text'>/**
</span> * The text field is the basis for most of the input fields. It provides a baseline of shared
 * functionality such as input validation, standard events, state management and look and feel. Typically we create
 * text fields inside a form, like this:
 *
 *     @example
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         fullscreen: true,
 *         items: [
 *             {
 *                 xtype: &#39;fieldset&#39;,
 *                 title: &#39;Enter your name&#39;,
 *                 items: [
 *                     {
 *                         xtype: &#39;textfield&#39;,
 *                         label: &#39;First Name&#39;,
 *                         name: &#39;firstName&#39;
 *                     },
 *                     {
 *                         xtype: &#39;textfield&#39;,
 *                         label: &#39;Last Name&#39;,
 *                         name: &#39;lastName&#39;
 *                     }
 *                 ]
 *             }
 *         ]
 *     });
 *
 * This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
 *
 *     Ext.create(&#39;Ext.field.Text&#39;, {
 *         label: &#39;Your Name&#39;,
 *         value: &#39;Ed Spencer&#39;
 *     });
 *
 * ## Configuring
 *
 * Text field offers several configuration options, including {@link #placeholder}, {@link #maxLength},
 * {@link #autoComplete}, {@link #autoCapitalize} and {@link #autoCorrect}. For example, here is how we would configure
 * a text field to have a maximum length of 10 characters, with placeholder text that disappears when the field is
 * focused:
 *
 *     Ext.create(&#39;Ext.field.Text&#39;, {
 *         label: &#39;Username&#39;,
 *         maxLength: 10,
 *         placeholder: &#39;Enter your username&#39;
 *     });
 *
 * The autoComplete, autoCapitalize and autoCorrect configs simply set those attributes on the text field and allow the
 * native browser to provide those capabilities. For example, to enable auto complete and auto correct, simply
 * configure your text field like this:
 *
 *     Ext.create(&#39;Ext.field.Text&#39;, {
 *         label: &#39;Username&#39;,
 *         autoComplete: true,
 *         autoCorrect: true
 *     });
 *
 * These configurations will be picked up by the native browser, which will enable the options at the OS level.
 *
 * Text field inherits from {@link Ext.field.Field}, which is the base class for all fields and provides
 * a lot of shared functionality for all fields, including setting values, clearing and basic validation. See the
 * {@link Ext.field.Field} documentation to see how to leverage its capabilities.
 */
Ext.define(&#39;Ext.field.Text&#39;, {
    extend: &#39;Ext.field.Input&#39;,
    xtype: &#39;textfield&#39;,
    alternateClassName: &#39;Ext.form.Text&#39;,

    requires: [
        &#39;Ext.field.trigger.Clear&#39;,
        &#39;Ext.Deferred&#39;
    ],

<span id='Ext-field-Text-event-focus'>    /**
</span>     * @event focus
     * Fires when this field receives input focus
     * @param {Ext.field.Text} this This field
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-blur'>    /**
</span>     * @event blur
     * Fires when this field loses input focus
     * @param {Ext.field.Text} this This field
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-paste'>    /**
</span>     * @event paste
     * Fires when this field is pasted.
     * @param {Ext.field.Text} this This field
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-mousedown'>    /**
</span>     * @event mousedown
     * Fires when this field receives a mousedown
     * @param {Ext.field.Text} this This field
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-keyup'>    /**
</span>     * @event keyup
     * @preventable
     * Fires when a key is released on the input element
     * @param {Ext.field.Text} this This field
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-clearicontap'>    /**
</span>     * @event clearicontap
     * @preventable
     * Fires when the clear icon is tapped
     * @param {Ext.field.Text} this This field
     * @param {Ext.field.Input} input The field&#39;s input component.
     * @param {Ext.event.Event} e
     */

<span id='Ext-field-Text-event-action'>    /**
</span>     * @event action
     * @preventable
     * Fires whenever the return key or go is pressed. FormPanel listeners
     * for this event, and submits itself whenever it fires. Also note
     * that this event bubbles up to parent containers.
     * @param {Ext.field.Text} this This field
     * @param {Mixed} e The key event object
     */

    config: {
<span id='Ext-field-Text-cfg-clearable'>        /**
</span>         * @cfg {Boolean} clearable
         * `true` to show a clear trigger in this field when it has a non-empty value
         */
        clearable: true,

<span id='Ext-field-Text-cfg-labelAlign'>        /**
</span>         * @cfg labelAlign
         * When value is `&#39;placeholder&#39;`, the label text will be rendered as placeholder
         * text inside the empty input and will animated to &quot;top&quot; alignment when the input
         * is focused or contains text.
         * @inheritdoc
         */

<span id='Ext-field-Text-cfg-placeholder'>        /**
</span>         * @cfg {String} placeholder
         * A string value displayed in the input when the control is empty.
         */
        placeholder: null,

<span id='Ext-field-Text-cfg-maxLength'>        /**
</span>         * @cfg {Number} maxLength
         * The maximum number of permitted input characters.
         */
        maxLength: null,

<span id='Ext-field-Text-cfg-autoComplete'>        /**
</span>         * @cfg {Boolean} [autoComplete=true]
         * `false to disable autocomplete on this text field.  Autocomplete is enabled by
         * default on text fields, but disabled on picker fields.
         */
        autoComplete: null,

<span id='Ext-field-Text-cfg-autoCapitalize'>        /**
</span>         * @cfg {Boolean} autoCapitalize
         * True to set the field&#39;s DOM element autocapitalize attribute to &quot;on&quot;, false to set to &quot;off&quot;.
         */
        autoCapitalize: null,

<span id='Ext-field-Text-cfg-autoCorrect'>        /**
</span>         * @cfg {Boolean} autoCorrect
         * True to set the field DOM element autocorrect attribute to &quot;on&quot;, false to set to &quot;off&quot;.
         */
        autoCorrect: null,

<span id='Ext-field-Text-cfg-autoHideInputMask'>        /**
</span>         * @cfg {Boolean} [autoHideInputMask=true]
         * Specify as `false` to always show the `inputMask`.
         * @since 6.5.0
         */
        autoHideInputMask: null,

<span id='Ext-field-Text-cfg-inputMask'>        /**
</span>         * @cfg {String/Ext.field.InputMask} inputMask
         *
         * **Important:** To use this config you must require `Ext.field.InputMask` or
         * use a complete framework build. The logic to implement an `inputMask` is not
         * automatically included in a build.
         * @since 6.5.0
         */
        inputMask: null,

<span id='Ext-field-Text-cfg-pattern'>        /**
</span>         * @cfg {String} pattern
         * The value for the HTML5 `pattern` attribute. You can use this to change which
         * keyboard layout will be used.
         *
         *     Ext.define(&#39;Ux.field.Pattern&#39;, {
         *         extend : &#39;Ext.field.Text&#39;,
         *         xtype  : &#39;patternfield&#39;,
         *
         *         config : {
         *             component : {
         *                 pattern : &#39;[0-9]*&#39;
         *             }
         *         }
         *     });
         *
         * Even though it extends {@link Ext.field.Text}, it will display the number keyboard.
         */
        pattern: null,

        // @cmd-auto-dependency {aliasPrefix: &quot;trigger.&quot;, isKeyedObject: true}
<span id='Ext-field-Text-cfg-triggers'>        /**
</span>         * @cfg {Object} triggers
         * {@link Ext.field.trigger.Trigger Triggers} to use in this field.  The keys in
         * this object are unique identifiers for the triggers. The values in this object
         * are {@link Ext.field.trigger.Trigger Trigger} configuration objects.
         *
         *     Ext.create(&#39;Ext.field.Text&#39;, {
         *         label: &#39;My Custom Field&#39;,
         *         triggers: {
         *             foo: {
         *                 cls: &#39;my-foo-trigger&#39;,
         *                 handler: function() {
         *                     console.log(&#39;foo trigger clicked&#39;);
         *                 }
         *             },
         *             bar: {
         *                 cls: &#39;my-bar-trigger&#39;,
         *                 handler: function() {
         *                     console.log(&#39;bar trigger clicked&#39;);
         *                 }
         *             }
         *         }
         *     });
         *
         * The weight value may be a negative value in order to position custom triggers
         * ahead of default triggers like that of a DatePicker field.
         *
         *     Ext.create(&#39;Ext.form.DatePicker&#39;, {
         *         label: &#39;Pick a Date&#39;,
         *         triggers: {
         *             foo: {
         *                 cls: &#39;my-foo-trigger&#39;,
         *                 weight: -2, // negative to place before default triggers
         *                 handler: function() {
         *                     console.log(&#39;foo trigger clicked&#39;);
         *                 }
         *             },
         *             bar: {
         *                 cls: &#39;my-bar-trigger&#39;,
         *                 weight: -1,
         *                 handler: function() {
         *                     console.log(&#39;bar trigger clicked&#39;);
         *                 }
         *             }
         *         }
         *     });
         */
        triggers: {
            clear: {
                type: &#39;clear&#39;
            }
        },

<span id='Ext-field-Text-cfg-editable'>        /**
</span>         * @cfg {Boolean} editable
         * Configure as `false` to prevent the user from typing text directly into the
         * field; the field can only have its value set programmatically or via an action
         * invoked by a trigger.
         *
         * Contrast with {@link #cfg!readOnly} which disables all mutation via the UI.
         */
        editable: true,

<span id='Ext-field-Text-cfg-bubbleEvents'>        bubbleEvents: [&#39;action&#39;],
</span>
<span id='Ext-field-Text-cfg-bodyAlign'>        /**
</span>         * @cfg bodyAlign
         * @hide
         */
        bodyAlign: &#39;stretch&#39;,

<span id='Ext-field-Text-cfg-labelInPlaceholder'>        /**
</span>         * @private
         */
        labelInPlaceholder: {
            lazy: true,
            $value: true
        },

<span id='Ext-field-Text-cfg-textAlign'>        /**
</span>         * @cfg {&#39;left&#39;/&#39;center&#39;/&#39;right&#39;} [textAlign=&#39;left&#39;]
         * The text alignment of this field.
         */
        textAlign: null
    },

    cachedConfig: {
<span id='Ext-field-Text-cfg-animateUnderline'>        /**
</span>         * @cfg {Boolean} animateUnderline
         * &#39;true&#39; to animate the underline of a field when focused
         */
        animateUnderline: false,

<span id='Ext-field-Text-cfg-parseValidator'>        /**
</span>         * @cfg {Ext.data.validator.Validator} parseValidator
         * @private
         * @since 6.5.1
         */
        parseValidator: null
    },

<span id='Ext-field-Text-cfg-badFormatMessage'>    /**
</span>     * @cfg {String} badFormatMessage
     * The error message that will be displayed if the value cannot be parsed (for some
     * derived types) or if the value does not match a configured {@link #inputMask}.
     * @locale
     * @since 6.5.0
     */
    badFormatMessage: &#39;Value does not match the required format&#39;,

<span id='Ext-field-Text-cfg-bodyAlign'>    /**
</span>     * @cfg bodyAlign
     * @hide
     */

<span id='Ext-field-Text-property-defaultBindProperty'>    /**
</span>     * @property defaultBindProperty
     * @inheritdoc
     */
    defaultBindProperty: &#39;value&#39;,

<span id='Ext-field-Text-cfg-twoWayBindable'>    /**
</span>     * @cfg twoWayBindable
     * @inheritdoc
     */
    twoWayBindable: {
        value: 1
    },

<span id='Ext-field-Text-cfg-publishes'>    /**
</span>     * @cfg publishes
     * @inheritdoc
     */
    publishes: {
        value: 1
    },

<span id='Ext-field-Text-cfg-inputType'>    /**
</span>     * @cfg inputType
     * @inheritdoc
     */
    inputType: &#39;text&#39;,

<span id='Ext-field-Text-property-classCls'>    /**
</span>     * @property classCls
     * @inheritdoc
     */
    classCls: Ext.baseCSSPrefix + &#39;textfield&#39;,
<span id='Ext-field-Text-property-focusedCls'>    focusedCls: Ext.baseCSSPrefix + &#39;focused&#39;,
</span><span id='Ext-field-Text-property-emptyCls'>    emptyCls: Ext.baseCSSPrefix + &#39;empty&#39;,
</span><span id='Ext-field-Text-property-webkitBorderBoxBugCls'>    webkitBorderBoxBugCls: Ext.baseCSSPrefix + &#39;webkit-border-box-bug&#39;,
</span>
<span id='Ext-field-Text-property-requiredIndicator'>    requiredIndicator: &#39;*&#39;,
</span>
<span id='Ext-field-Text-method-getBodyTemplate'>    getBodyTemplate: function () {
</span>        var template = [{
            reference: &#39;beforeInputElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;before-input-el&#39;
        }];

        template.push(this.getInputTemplate());

        template.push({
            reference: &#39;afterInputElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;after-input-el&#39;
        });

        return [{
            reference: &#39;inputWrapElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;input-wrap-el&#39; +
                (Ext.supports.WebKitInputTableBoxModelBug ? (&#39; &#39; + this.webkitBorderBoxBugCls) : &#39;&#39;),
            children: template
        }, {
            reference: &#39;underlineElement&#39;,
            cls: Ext.baseCSSPrefix + &#39;underline-el&#39;
        }];
    },

<span id='Ext-field-Text-method-initialize'>    initialize: function () {
</span>        var me = this;

        if (Ext.isRobot) {
            me.focusedInputDelay = 0;
        }

        me.callParent();

        me.inputElement.on({
            keyup: &#39;onKeyUp&#39;,
            keydown: &#39;onKeyDown&#39;,
            keypress: &#39;onKeyPress&#39;,
            paste: &#39;onPaste&#39;,
            mousedown: &#39;onMouseDown&#39;,
            scope: me
        });

        me.syncEmptyState();
    },

<span id='Ext-field-Text-method-clearValue'>    /**
</span>     * Clears the value of this field.
     */
    clearValue: function () {
        var me = this,
            inputMask = me.getInputMask();

        if (inputMask) {
            // show empty mask and move caret to first editable position
            inputMask.showEmptyMask(me, true);
        } else {
            me.forceInputChange = true;
            me.setValue(&#39;&#39;);
            me.forceInputChange = false;
        }

        me.syncEmptyState();
    },

<span id='Ext-field-Text-method-transformValue'>    transformValue: function (value) {
</span>        if (value == null) {
            value = &#39;&#39;;
        }

        return value;
    },

<span id='Ext-field-Text-method-applyInputMask'>    applyInputMask: function (value, instance) {
</span>        var InputMask = Ext.field[&#39;InputMask&#39;]; // prevent Cmd detection

        //&lt;debug&gt;
        if (value) {
            if (!InputMask) {
                Ext.raise(&#39;Missing Ext.field.InputMask (required to use inputMask)&#39;);
            }
        }
        //&lt;/debug&gt;

        return value ? InputMask.from(value, instance) : null;
    },

<span id='Ext-field-Text-method-updateInputMask'>    updateInputMask: function (inputMask, previous) {
</span>        this.hasMask = false;
        if (previous) {
            previous.release();
        }

        if (inputMask) {
            this.hasMask = true;
            //Synchronize pattern in case we have changed it and ensure that initial mask is being shown
            inputMask.syncPattern(this);
        }
    },

<span id='Ext-field-Text-method-doValidate'>    doValidate: function (value, errors, skipLazy) {
</span>        this.callParent([ value, errors, skipLazy ]);

        if (!skipLazy) {
            var inputMask = this.getInputMask();

            // Field will be marked invalid if user has entered some chars.
            if (inputMask &amp;&amp; !inputMask.isFilled(value) &amp;&amp; value !== inputMask._mask) {
                errors.push(this.badFormatMessage);
            }
        }
    },

<span id='Ext-field-Text-method-parseValue'>    /**
</span>     * Parses the given `value` and returns it in the desired representation. By default
     * this will return the `value` given (no change). Derived classes (such as `datefield`
     * and `numberfield`) will override this method and return a Date or a Number,
     * respectively.
     *
     * If `value` cannot be parsed, this method will return `null`, otherwise it will
     * return the parsed value. It is the parsed value that will become the field&#39;s
     * {@link #cfg!value value}.
     *
     * This method is not called directly but is called internally by the
     * {@link #method!validate validate method}. This call to parse a value is not made on
     * empty or null values.
     *
     * *Note:* It is not expected that applications will need to override this method
     * because an application can achieve value parsing by virtue of the `validators` it
     * defines. These can come from this component or from a bound model field (using
     * {@link #cfg!modelValidation}). In addition, `datefield` and `numberfield` both
     * provide default parsing for their values.
     *
     * @param {String} value The value to parse (never `null`).
     *
     * @param {String[]} errors The set of validation errors. If the value cannot be
     * parsed, the error message should be added to this array.
     *
     * @return {Mixed} The parsed value.
     *
     * @template
     * @protected
     * @since 6.5.1
     */
    parseValue: function (value, errors) {
        var me = this,
            parser = me.getParseValidator(),
            field, i, k, len, v, validators;

        if (parser) {
            // If the derived class has specified a default parseValidator, then this
            // pass is needed. Consult the component&#39;s validators first for a more
            // specific validator, followed by the bound model field (if we have one).
            field = me._validationField;

            for (k = 2; k-- &gt; 0; ) {
                validators = k ? me.getValidators() : (field &amp;&amp; field.getValidators());
                len = validators &amp;&amp; validators.length;

                for (i = 0; i &lt; len; ++i) {
                    v = validators[i];

                    if (v.parse) {
                        v = v.parse(value);

                        // The first parse validator to achieve a parse wins. Returns
                        // its result.
                        if (v !== null) {
                            return v;
                        }
                    }
                }
            }

            // No user-defined parse validator found, so run the default one. It must
            // succeed or the value is invalid.
            value = parser.parse(value);

            if (value === null &amp;&amp; errors) {
                errors.push(me.badFormatMessage);
            }
        }

        return value;
    },

<span id='Ext-field-Text-method-applyValue'>    applyValue: function (value, oldValue) {
</span>        // This converts the raw, textual value into whatever form the field uses
        // So Number and Date subclasses convert to number or date here.
        // If the validation fails, undefined return will abort the setter.
        if (value &amp;&amp; typeof value === &#39;string&#39;) {
            value = this.parseValue(value);
            if (value === null) {
                return;
            }
        }

        return this.transformValue(this.callParent([value, oldValue]));
    },

<span id='Ext-field-Text-method-updateInputValue'>    updateInputValue: function (value, oldValue) {
</span>        var me = this,
            inputMask = me.getInputMask();

        me.callParent([value, oldValue]);

        me.syncEmptyState();
        me.syncLabelPlaceholder(false);

        if (inputMask) {
            inputMask.onChange(this, value, oldValue);
        }
    },

<span id='Ext-field-Text-method-updateTextAlign'>    updateTextAlign: function (newAlign, oldAlign) {
</span>        var element = this.element;

        if (oldAlign) {
            element.removeCls(Ext.baseCSSPrefix + &#39;text-align-&#39; + oldAlign);
        }

        if (newAlign) {
            element.addCls(Ext.baseCSSPrefix + &#39;text-align-&#39; + newAlign);
        }
    },

<span id='Ext-field-Text-method-updatePlaceholder'>    updatePlaceholder: function (value) {
</span>        this.setInputAttribute(&#39;placeholder&#39;, value);
    },

<span id='Ext-field-Text-method-applyMaxLength'>    //&lt;debug&gt;
</span>    applyMaxLength: function (maxLength) {
        if (maxLength !== null &amp;&amp; typeof maxLength != &#39;number&#39;) {
            throw new Error(&quot;Ext.field.Text: [applyMaxLength] trying to pass a value which is not a number&quot;);
        }
        return maxLength;
    },
<span id='Ext-field-Text-method-updateMaxLength'>    //&lt;/debug&gt;
</span>
    updateMaxLength: function (newMaxLength) {
        this.setInputAttribute(&#39;maxlength&#39;, newMaxLength);
    },

<span id='Ext-field-Text-method-applyAutoComplete'>    applyAutoComplete: function (value) {
</span>        return value === true || value === &#39;on&#39;;
    },

<span id='Ext-field-Text-method-updateAutoComplete'>    updateAutoComplete: function (value) {
</span>        this.setInputAttribute(&#39;autocomplete&#39;, value ? &#39;on&#39; : &#39;off&#39;);
    },

<span id='Ext-field-Text-method-applyAutoCapitalize'>    applyAutoCapitalize: function (value) {
</span>        return value === true || value === &#39;on&#39;;
    },

<span id='Ext-field-Text-method-updateAutoCapitalize'>    updateAutoCapitalize: function (value) {
</span>        this.setInputAttribute(&#39;autocapitalize&#39;, value ? &#39;on&#39; : &#39;off&#39;);
    },

<span id='Ext-field-Text-method-applyAutoCorrect'>    applyAutoCorrect: function (value) {
</span>        return value === true || value === &#39;on&#39;;
    },

<span id='Ext-field-Text-method-updateAutoCorrect'>    updateAutoCorrect: function (value) {
</span>        this.setInputAttribute(&#39;autocorrect&#39;, value ? &#39;on&#39; : &#39;off&#39;);
    },

<span id='Ext-field-Text-method-updateReadOnly'>    updateReadOnly: function (newReadOnly) {
</span>        var me = this,
            triggers = me.getTriggers(),
            isEditable = me.getEditable(),
            triggerName, trigger;

        me.callParent([newReadOnly || !isEditable]);

        for (triggerName in triggers) {
            trigger = triggers[triggerName];

            if (trigger.disableOnReadOnly !== false) {
                trigger.setDisabled(newReadOnly);
            }
        }

        me.syncEmptyState();
    },

<span id='Ext-field-Text-method-updateEditable'>    updateEditable: function (newEditable) {
</span>        var triggers = this.getTriggers(),
            isReadOnly = this.getReadOnly(),
            triggerName, trigger;

        this.updateReadOnly(!newEditable);
        for (triggerName in triggers) {
            trigger = triggers[triggerName];

            if (trigger.disableOnReadOnly !== false) {
                triggers[triggerName].setDisabled(isReadOnly);
            }
        }
    },

<span id='Ext-field-Text-method-updatePattern'>    updatePattern: function (pattern) {
</span>        this.setInputAttribute(&#39;pattern&#39;, pattern);
    },

<span id='Ext-field-Text-method-updateDisabled'>    updateDisabled: function (disabled, oldDisabled) {
</span>        this.callParent([disabled, oldDisabled]);
        this.syncEmptyState();
    },

<span id='Ext-field-Text-method-updateClearable'>    updateClearable: function (clearable, oldClearable) {
</span>        var me = this,
            triggers, clearTrigger;

        if (!me.isConfiguring) {
            triggers = me.getTriggers();
            clearTrigger = triggers &amp;&amp; triggers.clear;

            if (clearable) {
                if (!clearTrigger) {
                    me.addTrigger(&#39;clear&#39;, &#39;clear&#39;);
                }
            } else if (clearTrigger) {
                me.removeTrigger(&#39;clear&#39;);
            }
        }
    },

<span id='Ext-field-Text-method-applyTriggers'>    applyTriggers: function (triggers, oldTriggers) {
</span>        var me = this,
            instances = oldTriggers || {},
            clearable = me.getClearable(),
            name, trigger, oldTrigger;

        for (name in triggers) {
            trigger = triggers[name];
            oldTrigger = instances[name];

            // Any key that exists on the incoming object should cause destruction of
            // the existing trigger for that key, if one exists.  This is true for both
            // truthy values (triggers and trigger configs) and falsy values. Falsy values
            // cause destruction of the existing trigger without replacement.
            if (oldTrigger) {
                oldTrigger.destroy();
            }

            if (trigger) {
                if (!clearable &amp;&amp; (name === &#39;clear&#39;)) {
                    continue;
                }

                instances[name] = me.createTrigger(name, trigger);
            }
        }

        return instances;
    },

<span id='Ext-field-Text-method-updateTriggers'>    updateTriggers: function () {
</span>        this.syncTriggers();
    },

<span id='Ext-field-Text-method-addTrigger'>    /**
</span>     * Adds a trigger to this text field.
     * @param {String} name Unique name (within this field) for the trigger.  Cannot be the
     * same as the name of an existing trigger for this field.
     * @param {Ext.field.trigger.Trigger/Object} trigger The trigger instance or a config
     * object for a trigger to add
     * @return {Ext.field.trigger.Trigger} The trigger that was added
     */
    addTrigger: function (name, trigger) {
        var me = this,
            triggers = me.getTriggers(),
            triggerConfig;

        //&lt;debug&gt;
        if (triggers &amp;&amp; triggers[name]) {
            Ext.raise(&#39;Trigger with name &quot;&#39; + name + &#39;&quot; already exists.&#39;);
        }
        if (typeof name !== &#39;string&#39;) {
            Ext.raise(&#39;Cannot add trigger. Key must be a string.&#39;);
        }
        if (typeof trigger !== &#39;string&#39; &amp;&amp; !Ext.isObject(trigger)) {
            Ext.raise(&#39;Cannot add trigger &quot;&#39; + name + &#39;&quot;. A trigger config or instance is required.&#39;);
        }
        //&lt;/debug&gt;

        trigger = me.createTrigger(name, trigger);

        if (triggers) {
            triggers[name] = trigger;
            me.syncTriggers();
        } else {
            triggerConfig = {};
            triggerConfig[name] = trigger;
            me.setTriggers(triggerConfig);
        }

        return trigger;
    },

<span id='Ext-field-Text-method-removeTrigger'>    /**
</span>     * Removes a trigger from this text field.
     * @param {String/Ext.field.trigger.Trigger} trigger The name of the trigger to remove,
     * or a trigger reference.
     * @param {Boolean} [destroy=true] False to prevent the trigger from being destroyed
     * on removal.  Only use this option if you want to reuse the trigger instance.
     * @return {Ext.field.trigger.Trigger} The trigger that was removed
     */
    removeTrigger: function (trigger, destroy) {
        var me = this,
            triggers = me.getTriggers(),
            name = trigger,
            triggerEl;

        if (name.isTrigger) {
            name = trigger.getName();
        } else {
            trigger = triggers[name];
        }

        //&lt;debug&gt;
        if (!name) {
            Ext.raise(&#39;Trigger not found.&#39;);
        } else if (!triggers[name]) {
            Ext.raise(&#39;Cannot remove trigger. Trigger with name &quot;&#39; + name + &#39;&quot; not found.&#39;);
        }
        //&lt;/debug&gt;

        delete triggers[name];

        if (destroy !== false) {
            trigger.destroy();
        } else {
            triggerEl = trigger.el.dom;
            triggerEl.parentNode.removeChild(triggerEl);
        }

        this.syncTriggers();

        return trigger;
    },

<span id='Ext-field-Text-method-onKeyDown'>    onKeyDown: function (event) {
</span>        var me = this,
            inputMask = me.getInputMask();

        me.lastKeyTime = Date.now();
        if (inputMask) {
            inputMask.onKeyDown(me, me.getValue(), event);
        }

        // tell the class to ignore the input event. this happens when we want to listen
        // to the field change when the input autocompletes
        me.ignoreInput = true;

        if (Ext.supports.SpecialKeyDownRepeat) {
            me.fireKey(event);
        }
    },

<span id='Ext-field-Text-method-onInput'>    onInput: function (e) {
</span>        var me = this,
            inputEl = me.inputElement.dom,
            value = inputEl.value,
            inputMask = me.getInputMask(),
            parseErrors, oldValue;

        if (inputMask) {
            inputMask.processAutocomplete(this, value);
            value = inputEl.value;
        }

        // Keep our config up to date:
        me._inputValue = value;

        // If the value is empty don&#39;t try and parse it, use the result
        // of parseValue as the default. For text fields it will be empty string,
        // for other typed fields (number/date) it will be null
        if (value) {
            parseErrors = [];
            value = me.parseValue(value, parseErrors);
        }
        if (parseErrors &amp;&amp; parseErrors.length) {
            me.setError(parseErrors);
        } else {
            oldValue = me.getValue();
            me.setValue(value);

            // If the value did not change, revalidate.
            // The user may have just erased into a valid state from an invalid state.
            if (me.getValue() === oldValue) {
                me.validate();
            }
        }

        me.syncEmptyState();

        // if we should ignore input, stop now.
        if (me.ignoreInput) {
            me.ignoreInput = false;
            return;
        }

        // set a timeout for 10ms to check if we want to stop the input event.
        // if not, then continue with the event (keyup)
        Ext.defer(function () {
            if (!me.ignoreInput &amp;&amp; !me.destroyed) {
                me.fireEvent(&#39;keyup&#39;, e);
                me.ignoreInput = false;
            }
        }, 10);
    },

<span id='Ext-field-Text-method-fireKey'>    /**
</span>     * @private
     */
    fireKey: function (e) {
        if (e.isSpecialKey()) {
            this.fireEvent(&#39;specialkey&#39;, this, e);
        }
    },

<span id='Ext-field-Text-method-onKeyPress'>    onKeyPress: function (event) {
</span>        var me = this,
            inputMask = me.getInputMask();

        if (inputMask) {
            inputMask.onKeyPress(me, me.getValue(), event);
        }

        me.fireEvent(&#39;keypress&#39;, me, event);

        if (!Ext.supports.SpecialKeyDownRepeat) {
            me.fireKey(event);
        }
    },

<span id='Ext-field-Text-method-onKeyUp'>    onKeyUp: function (e) {
</span>        this.fireAction(&#39;keyup&#39;, [this, e], &#39;doKeyUp&#39;);
    },

<span id='Ext-field-Text-method-doKeyUp'>    /**
</span>     * Called when a key has been pressed in the `&lt;input&gt;`
     * @private
     */
    doKeyUp: function (me, e) {
        me.syncEmptyState();

        if (e.browserEvent.keyCode === 13) {
            me.fireAction(&#39;action&#39;, [me, e], &#39;doAction&#39;);
        }
    },

<span id='Ext-field-Text-method-doAction'>    doAction: function () {
</span>        // Blur fields on enter on virtual keyboard platforms.
        // The virtual keyboard pushes the document up outside the viewport bounds.
        if (document.documentElement.getBoundingClientRect().top &lt; 0) {
            this.blur();
        }
    },

<span id='Ext-field-Text-method-onClearIconTap'>    onClearIconTap: function (input, e) {
</span>        this.fireAction(&#39;clearicontap&#39;, [this, input, e], &#39;doClearIconTap&#39;);
    },

<span id='Ext-field-Text-method-doClearIconTap'>    /**
</span>     * @private
     */
    doClearIconTap: function () {
        this.clearValue();
    },

<span id='Ext-field-Text-method-onFocusEnter'>    onFocusEnter: function (event) {
</span>        var me = this,
            inputMask = me.getInputMask();

        me.callParent([event]);

        me.addCls(me.focusedCls);
        me.syncLabelPlaceholder(true);

        if (inputMask) {
            inputMask.onFocus(me, me.getValue());
        }
    },

<span id='Ext-field-Text-method-onFocusLeave'>    onFocusLeave: function (event) {
</span>        var me = this,
            inputMask = me.getInputMask();

        me.callParent([event]);

        me.removeCls(me.focusedCls);
        me.syncLabelPlaceholder(true);

        if (inputMask) {
            inputMask.onBlur(me, me.getValue());
        }
    },

<span id='Ext-field-Text-method-onPaste'>    onPaste: function (e) {
</span>        this.forceInputChange = true;
        this.handlePaste(e);
        this.forceInputChange = false;
    },

<span id='Ext-field-Text-method-getCaretPos'>    getCaretPos: function () {
</span>        return this.inputElement.getCaretPos();
    },

<span id='Ext-field-Text-method-setCaretPos'>    setCaretPos: function (pos) {
</span>        this.inputElement.setCaretPos(pos);
    },

<span id='Ext-field-Text-method-getTextSelection'>    /**
</span>     * Returns the selection range of an input element as an array of three values:
     *
     *      [ start, end, direction ]
     *
     * These have the same meaning as the parameters to `select`.
     * @return {Array}
     * @since 6.5.0
     */
    getTextSelection: function () {
        return this.inputElement.getTextSelection();
    },

<span id='Ext-field-Text-method-select'>    /**
</span>     * Select the specified contents of the input field (all by default).
     * @param {Number} [start=0]
     * @param {Number} [end]
     * @param {&quot;f&quot;/&quot;b&quot;/&quot;forward&quot;/&quot;backward&quot;} [direction=&quot;f&quot;] Pass &quot;f&quot; for forward,
     * &quot;b&quot; for backwards.
     * @return {Ext.field.Text} this
     * @chainable
     */
    select: function (start, end, direction) {
        // Safari has a bug where selecting text in an input element focuses that
        // input element. If we do not contain focus, do nothing. We select on focus
        // anyway.
        if (this.containsFocus) {
            this.inputElement.selectText(start, end, direction);
        }

        return this;
    },

<span id='Ext-field-Text-method-reset'>    reset: function () {
</span>        this.callParent();

        this.syncEmptyState();
    },

<span id='Ext-field-Text-method-onClick'>    onClick: function (e) {
</span>        this.fireEvent(&#39;click&#39;, e);
    },

<span id='Ext-field-Text-method-onMouseDown'>    onMouseDown: function (e) {
</span>        this.fireEvent(&#39;mousedown&#39;, e);
    },

<span id='Ext-field-Text-method-trimValueToMaxLength'>    trimValueToMaxLength: function () {
</span>        var me = this,
            maxLength = me.getMaxLength(),
            value = me.getValue();

        if (maxLength &amp;&amp; value.length &gt; maxLength) {
            me.setValue(value.slice(0, maxLength));
        }
    },

<span id='Ext-field-Text-method-doDestroy'>    doDestroy: function () {
</span>        var me = this,
            triggers = me.getTriggers(),
            triggerGroups = me.triggerGroups,
            name, animation;

        animation = me.labelElement &amp;&amp; me.labelElement.getActiveAnimation();

        if (animation) {
            animation.stop();
        }

        if (triggerGroups) {
            for (name in triggerGroups) {
                triggerGroups[name].destroy();
            }
            me.triggerGroups = null;
        }

        for (name in triggers) {
            triggers[name].destroy();
        }

        me.setTriggers(null);
        me.setInputMask(null);

        me.callParent();
    },

<span id='Ext-field-Text-method-onRender'>    onRender: function () {
</span>        this.callParent();

        this.syncLabelPlaceholder();
    },

<span id='Ext-field-Text-method-getRefItems'>    getRefItems: function (deep) {
</span>        var me = this,
            triggers = me.getTriggers(),
            items = [],
            triggerName, trigger;

        for (triggerName in triggers) {
            trigger = triggers[triggerName];
            items.push(trigger);

            // component triggers have ref items of their own
            if (deep &amp;&amp; trigger.getRefItems) {
                items.push.apply(items, trigger.getRefItems(deep));
            }
        }

        return items;
    },

<span id='Ext-field-Text-property-privates'>    privates: {
</span>        focusedInputDelay: 300,
        forceInputChange: false,
        hasMask: false,
        lastKeyTime: 0,

        applyParseValidator: function (config) {
            return this.decodeValidator(config);
        },

        updateLabelInPlaceholder: function (inside) {
            var me = this,
                placeHolder = me.getPlaceholder() || &#39;&#39;,
                anim = me._animPlaceholderLabel;

            if (me.getLabelAlign() !== &#39;placeholder&#39; || !me.getLabel()) {
                me.clearWhenVisible(&#39;doPositionPlaceholder&#39;);
                me.setInputAttribute(&#39;placeholder&#39;, placeHolder);
                return;
            }

            me.whenVisible(&#39;doPositionPlaceholder&#39;, [inside, anim]);
            me.el.toggleCls(Ext.baseCSSPrefix + &#39;label-inside&#39;, inside);
        },

        updateAnimateUnderline: function (value) {
            this.toggleCls(Ext.baseCSSPrefix + &#39;animate-underline&#39;, value);
        },

        canSetInputValue: function () {
            var me = this;
            // If we&#39;re using an inputMask, the field is updated dynamically
            // as typing occurs. forceInputChange is for when the component wants
            // to force the value to change, for example selecting from a picker,
            // or after consuming a paste. If we are focused, make sure enough
            // of a delay has passed so that we&#39;re not overwriting the value
            // as the user is typing, which typically means the value will
            // have come from a setValue call elsewhere, as opposed to
            // from typing.
            return me.hasMask || me.forceInputChange || !me.hasFocus ||
                Date.now() - me.lastKeyTime &gt; me.focusedInputDelay;
        },

        doPositionPlaceholder: function (inside, doAnimate) {
            var me = this,
                labelElement = me.labelElement,
                anim, animation, info, insideInfo, outsideInfo;

            animation = labelElement.getActiveAnimation();
            if (animation) {
                animation.stop();
            }

            info = me.lastPlaceholderAnimInfo;
            if (!info) {
                me.lastPlaceholderAnimInfo = info = me.getPlaceholderAnimInfo();
            }
            insideInfo = info.inside;
            outsideInfo = info.outside;

            anim = {
                from: inside ? outsideInfo : insideInfo,
                to: inside ? insideInfo : outsideInfo,
                preserveEndState: true,
                duration: 250,
                easing: &#39;ease-out&#39;
            };

            if (doAnimate) {
                labelElement.animate(anim);
            } else {
                labelElement.setStyle(anim.to);
            }
        },

        getPlaceholderLabel: function () {
            var me = this,
                label = me.getLabel();

            if (label &amp;&amp; me.getRequired()) {
                label += &#39; &#39; + me.requiredIndicator;
            }

            return label;
        },

        getPlaceholderAnimInfo: function () {
            var me = this,
                element = me.element,
                labelElement = me.labelElement,
                inputElement = me.inputElement,
                labelOffsets = labelElement.getOffsetsTo(element),
                inputOffsets = inputElement.getOffsetsTo(element),
                labelLeftPadding = labelElement.getPadding(&#39;l&#39;),
                inputLeftPadding = inputElement.getPadding(&#39;l&#39;),
                labelTopPadding = labelElement.getPadding(&#39;t&#39;),
                inputTopPadding = inputElement.getPadding(&#39;t&#39;),
                translateX = inputOffsets[0] - labelOffsets[0] + (inputLeftPadding - labelLeftPadding),
                translateY = inputOffsets[1] - labelOffsets[1] + (inputTopPadding - labelTopPadding);

            return {
                inside: {
                    transform: {
                        translateX: translateX + &#39;px&#39;,
                        translateY: translateY + &#39;px&#39;
                    },
                    &#39;font-size&#39;: inputElement.getStyle(&#39;font-size&#39;)
                },
                outside: {
                    transform: {
                        translateX: &#39;0px&#39;,
                        translateY: &#39;0px&#39;
                    },
                    &#39;font-size&#39;: labelElement.getStyle(&#39;font-size&#39;)
                }
            };
        },

        handlePaste: function (e) {
            var me = this,
                inputMask = me.getInputMask();

            if (inputMask) {
                inputMask.onPaste(me, me.getValue(), e);
            }

            me.fireEvent(&#39;paste&#39;, me, e);
        },

<span id='Ext-field-Text-method-createTrigger'>        /**
</span>         * @private
         */
        createTrigger: function (name, trigger) {
            if (!trigger.isTrigger) {
                if (trigger === true) {
                    trigger = {
                        type: name
                    };
                } else if (typeof trigger === &#39;string&#39;) {
                    trigger = {
                        type: trigger
                    };
                }

                trigger = Ext.apply({
                    name: name,
                    field: this
                }, trigger);

                trigger = trigger.xtype ? Ext.create(trigger) : Ext.Factory.trigger(trigger);
            }

            return trigger;
        },

        syncLabelPlaceholder: function (animate) {
            var me = this,
                inputEl = me.inputElement,
                value = inputEl &amp;&amp; inputEl.dom.value,
                inside;

            me._animPlaceholderLabel = animate;

            if (me.rendered) {
                if (value !== &#39;&#39;) {
                    // The cardinal rule: if there is a value do NOT put the label on
                    // top of it!
                    inside = false;
                }
                else {
                    // Otherwise, if the input is not focused we would generally put
                    // the label on top to act as the placeholder. Or flipped, when
                    // the input is focused we want to move the label outside. That
                    // is UNLESS the field is disabled or readonly since doing that
                    // move-to-outside would make it seem like the field is editable
                    // in some way (which it is not).
                    inside = !me.hasFocus || me.getDisabled() || me.getReadOnly();
                }

                me.setLabelInPlaceholder(inside);
            }

            me._animPlaceholderLabel = false;
        },

<span id='Ext-field-Text-method-syncTriggers'>        /**
</span>         * Synchronizes the DOM to match the triggers&#39; configured weight, side, and grouping
         * @private
         */
        syncTriggers: function () {
            var me = this,
                triggers = me.getTriggers(),
                beforeInputElement = me.beforeInputElement,
                afterInputElement = me.afterInputElement,
                triggerGroups = me.triggerGroups || (me.triggerGroups = {}),
                beforeTriggers = [],
                afterTriggers = [],
                triggersByGroup = {},
                TriggerBase = Ext.field.trigger[&#39;Base&#39;],
                name, trigger, groupName, triggerGroup, i, ln;

            for (name in triggers) {
                trigger = triggers[name];

                groupName = trigger.getGroup();

                if (groupName) {
                    (triggersByGroup[groupName] || (triggersByGroup[groupName] = [])).push(trigger);
                } else if (trigger.getSide() === &#39;left&#39;) {
                    beforeTriggers.push(trigger);
                } else {
                    afterTriggers.push(trigger);
                }
            }

            for (groupName in triggersByGroup) {
                triggerGroup = triggerGroups[groupName];

                if (!triggerGroup) {
                    triggerGroup = triggers[groupName]; // just in case the user configured a group trigger

                    if (!triggerGroup) {
                        triggerGroup = new TriggerBase();
                    }

                    triggerGroups[groupName] = triggerGroup;
                }

                triggerGroup.setTriggers(TriggerBase.sort(triggersByGroup[groupName]));

                if (triggerGroup.getSide() === &#39;left&#39;) {
                    beforeTriggers.push(triggerGroup);
                } else {
                    afterTriggers.push(triggerGroup);
                }
            }

            TriggerBase.sort(beforeTriggers);
            TriggerBase.sort(afterTriggers);

            for (i = 0, ln = beforeTriggers.length; i &lt; ln; i++) {
                beforeInputElement.appendChild(beforeTriggers[i].element);
            }

            for (i = 0, ln = afterTriggers.length; i &lt; ln; i++) {
                afterInputElement.appendChild(afterTriggers[i].element);
            }

            for (groupName in triggerGroups) {
                if (!(groupName in triggersByGroup)) {
                    // group no longer has any triggers. it can be removed.
                    triggerGroup = triggerGroups[groupName];
                    triggerGroup.setTriggers(null);
                    triggerGroup.destroy();
                    delete triggerGroups[groupName];
                }
            }
        },

        syncEmptyState: function () {
            var me = this,
                triggers = me.getTriggers(),
                inputMask = me.getInputMask(),
                clearTrigger = triggers &amp;&amp; triggers.clear,
                value = me.inputElement.dom.value,
                visible;

            me.toggleCls(me.emptyCls, !value);

            if (clearTrigger) {
                if (me.getClearable()) {
                    if (value !== &#39;&#39; &amp;&amp; !me.getDisabled() &amp;&amp; !me.getReadOnly()) {
                        visible = true;
                    }

                    if (inputMask) {
                        // Don&#39;t show clear trigger if there is no real input in the field
                        if (value === inputMask._mask) {
                            visible = false;
                        }
                    }
                }

                if (visible) {
                    clearTrigger.show();
                } else {
                    clearTrigger.hide();
                }
            }
        }
    },

<span id='Ext-field-Text-property-deprecated'>    deprecated: {
</span>        &#39;6.5&#39;: {
            configs: {
<span id='Ext-field-Text-cfg-placeHolder'>                /**
</span>                 * @cfg {String} placeHolder
                 * A string value displayed in the input when the control is empty.
                 * @deprecated 6.5.0 Use the all lowercase {@link #placeholder} config.
                 */
                placeHolder: &#39;placeholder&#39;,
                clearIcon: &#39;clearable&#39;
            },
            methods: {
                getPlaceHolder: &#39;getPlaceholder&#39;,
                setPlaceHolder: &#39;setPlaceholder&#39;
            }
        }
    }
},
function() {
    // Fix for android active field not scrolled into view when keyboard is shown
    if (Ext.os.is.Android) {
        window.addEventListener(&#39;resize&#39;, function () {
            var el = document.activeElement,
                tag = el &amp;&amp; el.tagName;
            
            if (tag === &#39;INPUT&#39; || tag === &#39;TEXTAREA&#39;) {
                el.scrollIntoView();
            }
        });
    }
});
</pre>
</body>
</html>
