<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='SU-panel-Accordion'>/**
</span> *
 * Расширение панели для управления дочерними панелями в стиле аккордеона.
 *
 * _Примечание:_ Это расширение будет применено только к элементам типа `Ext.Panel` и его подклассам.
 * Все остальные элементы будут работать как обычно.
 *
 * По умолчанию только одна дочерняя панель может быть в развернутом виде.
 *
 *
 *     @example
 *     Ext.create({
 *         xtype: &#39;accordion&#39;,
 *         title: &#39;Accordion Panel&#39;,
 *         animationPanel: { duration: 150 },
 *         fullscreen: true,
 *
 *         defaults: {
 *             xtype: &#39;panel&#39;,
 *             bodyPadding: 10,
 *             scrollable: true,
 *             flex: 1,
 *             layout: &#39;fit&#39;
 *         },
 *
 *         items: [{
 *             title: &#39;Panel 1&#39;,
 *             collapsed: false,
 *             html: &#39;Panel 1 content!&#39;
 *         }, {
 *             title: &#39;Panel 2&#39;,
 *             html: &#39;Panel 2 content!&#39;
 *         }, {
 *             title: &#39;Panel 3&#39;,
 *             html: &#39;Panel 3 content!&#39;
 *         }]
 *     });
 *
 * Для включения множественного режима установите #collapseByDefault в `false`.
 *
 *
 *     @example
 *     Ext.create({
 *         xtype: &#39;accordion&#39;,
 *         title: &#39;Accordion Panel&#39;,
 *         fullscreen: true,
 *         collapseByDefault: false,
 *         scrollable: true,
 *
 *         defaults: {
 *             xtype: &#39;panel&#39;,
 *             bodyPadding: 10,
 *             layout: &#39;fit&#39;
 *         },
 *
 *         items: [{
 *             title: &#39;Panel 1&#39;,
 *             html: &#39;Panel 1 content!&#39;
 *         }, {
 *             title: &#39;Panel 2&#39;,
 *             html: &#39;Panel 2 content!&#39;
 *         }, {
 *             title: &#39;Panel 3&#39;,
 *             html: &#39;Panel 3 content!&#39;
 *         }, {
 *             title: &#39;Panel 4&#39;,
 *             html: &#39;Panel 4 content!&#39;
 *         }]
 *     });
 *
 */
Ext.define(&#39;SU.panel.Accordion&#39;, function (Accordion) {
    if (Ext.versions.extjs.gtEq(&#39;7.0&#39;)) {
        return {
            extend: &#39;Ext.panel.Accordion&#39;
        };
    }

    return {
        extend: &#39;Ext.Panel&#39;,
        xtype: &#39;accordion&#39;,

        mixins: [&#39;Ext.mixin.Bufferable&#39;],

        requires: [&#39;Ext.layout.VBox&#39;, &#39;Ext.panel.Collapser&#39;],

        config: {
<span id='SU-panel-Accordion-cfg-collapseByDefault'>            /**
</span>             * @cfg {Boolean} collapseByDefault
             * Флаг, указывающий, должны ли сворачиваться все оставшиеся панели
             * при открытии одной из них
             */
            collapseByDefault: true,

<span id='SU-panel-Accordion-cfg-defaultPanelUI'>            /**
</span>             * @cfg {String} defaultPanelUI
             * {@link Ext.Widget#ui ui} по умолчанию для назначения свертываемым панелям.
             */
            defaultPanelUI: &#39;accordion&#39;,

<span id='SU-panel-Accordion-cfg-headerPanelClickable'>            /**
</span>             * @cfg {Boolean} headerPanelClickable
             * Свертывние / развертывание панели по клику на заголовке
             */
            headerPanelClickable: true,

<span id='SU-panel-Accordion-cfg-animationPanel'>            /**
</span>             * @cfg {Boolean/Object}
             * @inheritdoc Ext.panel.Collapser#animation
             */
            animationPanel: false
        },

<span id='SU-panel-Accordion-cfg-layout'>        layout: {
</span>            type: &#39;vbox&#39;
        },

<span id='SU-panel-Accordion-property-bufferableMethods'>        bufferableMethods: {
</span>            syncState: &#39;asap&#39;
        },

<span id='SU-panel-Accordion-property-accordionCls'>        /**
</span>         * @property {String}
         * CSS класс элемента #bodyEl
         */
        accordionCls: Ext.baseCSSPrefix + &#39;layout-accordion&#39;,

<span id='SU-panel-Accordion-property-accordionSelector'>        /**
</span>         * @property {String}
         * Селектор выборки панелей, участвующих в выравнивании
         * @protected
         */
        accordionSelector: &#39;&gt; [isPanel][collapsible][isInner]&#39;,

<span id='SU-panel-Accordion-method-initialize'>        //prioritySeed: 0,
</span>
        initialize: function () {
            var me = this;

            me.callParent(arguments);

            me.on({
                scope: me,
                delegate: me.accordionSelector,
                priority: -1000,

                beforecollapse: &#39;onPanelBeforeCollapse&#39;,
                beforeexpand: &#39;onPanelBeforeExpand&#39;,
                beforehiddenchange: &#39;onBeforePanelHiddenChange&#39;,

                collapse: &#39;onPanelCollapse&#39;,
                expand: &#39;onPanelExpand&#39;,
                hiddenchange: &#39;onPanelHiddenChange&#39;
            });

            me.getRenderTarget().addCls(me.accordionCls);
            me.syncStateNow();
        },

<span id='SU-panel-Accordion-method-onItemAdd'>        onItemAdd: function (item, index) {
</span>            var me = this,
                initialItemConfig = item.initialConfig,
                startCollapsed = initialItemConfig.collapsed,
                animationPanel = me.getAnimationPanel(),
                collapsible;

            if (item.isPanel &amp;&amp; item.isInnerItem()) {
                collapsible = item.getCollapsible();

                if (collapsible !== false) {
                    // Ставим обработчик клика на заголовке
                    if (me.getHeaderPanelClickable()) {
                        me.bindHeaderEvent(item, true);
                    }

                    // ui на панель
                    if (!item.getUi() &amp;&amp; !initialItemConfig.ui) {
                        item.$accordionUI = me;
                        item.setUi(me.getDefaultPanelUI());
                    }

                    // Настраиваем collapsible
                    if (collapsible) {
                        collapsible.setUseDrawer(false);
                        collapsible.setAnimation(animationPanel);
                        collapsible.setDynamic(true);
                    } else {
                        // Если collapsible явно не определен
                        // нужно смотреть настройку initialItemConfig.collapsed
                        // что бы настроить его,
                        // по умолчанию панель свернута
                        item.setCollapsible({
                            collapsed: Ext.isDefined(startCollapsed) ? startCollapsed : true,
                            animation: animationPanel,
                            dynamic: true,
                            useDrawer: false
                        });
                    }

                    // Посчитаем приоритеты
                }
            }

            me.callParent([item, index]);
        },

<span id='SU-panel-Accordion-method-onItemRemove'>        onItemRemove: function (item, index, destroying) {
</span>            var me = this,
                collapsible;

            // Очищаем UI складной панели (но не другие вещи, такие как пристыкованные элементы).
            if (item.$accordionUI === me &amp;&amp; item.getUi() === me.getDefaultPanelUI()) {
                item.$accordionUI = null;
                item.setUi(null);
            }

            if (item.isPanel &amp;&amp; item.isInnerItem()) {
                collapsible = item.getCollapsible();

                if (collapsible !== false) {
                    // Снимаем обработчик клика на заголовке
                    if (me.getHeaderPanelClickable()) {
                        me.bindHeaderEvent(item, false);
                    }
                }
            }

            me.syncState();

            me.callParent([item, index, destroying]);
        },

<span id='SU-panel-Accordion-method-updateCollapseByDefault'>        updateCollapseByDefault: function (value) {
</span>            this.syncStateNow();
        },

<span id='SU-panel-Accordion-method-updateHeaderPanelClickable'>        updateHeaderPanelClickable: function (value) {
</span>            var me = this,
                panels = me.query(me.accordionSelector);

            panels.forEach(function (item) {
                me.bindHeaderEvent(item, value);
            });
        },

<span id='global-property-privates'>        // @ignore
</span>        privates: {
            // Установка/снятие обработчика клика на заголовке
            bindHeaderEvent: function (panel, set) {
                var me = this,
                    header = panel.getHeader();

                fn = set ? &#39;on&#39; : &#39;un&#39;;

                header[fn].call(header, {
                    scope: me,
                    click: &#39;onPanelHeaderClick&#39;,
                    element: &#39;element&#39;
                });
            },

<span id='SU-panel-Accordion-method-getAccordionPanels'>            /**
</span>             * @return {Array}
             * @private
             */
            getAccordionPanels: function () {
                var me = this,
                    items = me.query(me.accordionSelector),
                    expanded = [],
                    n = items.length,
                    i,
                    item;

                //items.sort(me._sortFn);

                for (i = 0; i &lt; n; ++i) {
                    item = items[i];

                    if (item.getHidden()) {
                        items.splice(i, 1);
                        --n;
                        --i;
                    } else if (!item.getCollapsed()) {
                        expanded.push(item);
                    }
                }

                items.$expanded = expanded;

                return items;
            },

            onPanelBeforeCollapse: function (panel) {
                var me = this,
                    panels,
                    index;

                // В процессе анимации никаких действий, пока не закончится
                if (panel.$animating) return false;

                if (!me.getCollapseByDefault()) {
                    panel.$animating = true;
                    return true;
                }

                panels = me.getAccordionPanels();
                index = panels.indexOf(panel);

                if (panels.$expanded.length === 1) {
                    if (index === panels.length - 1) {
                        panel = panels[index - 1];
                    } else {
                        panel = panels[index + 1];
                    }

                    panel &amp;&amp; panel.expand();
                    return false;
                }

                // Включаем индикатор процесса анимации
                panel.$animating = true;
            },

            onPanelBeforeExpand: function (panel) {
                // В процессе анимации никаких действий, пока не закончится
                if (panel.$animating) return false;

                // Включаем индикатор процесса анимации
                panel.$animating = true;
            },

            onPanelCollapse: function (panel) {
                delete panel.$animating;
            },

            onPanelExpand: function (panel) {
                var me = this;

                delete panel.$animating;

                if (me.getCollapseByDefault()) {
                    me.getAccordionPanels().forEach(function (child) {
                        if (panel !== child) {
                            child.collapse();
                        }
                    });
                }
            },

            onBeforePanelHiddenChange: function (panel, hidden) {
                if (hidden) {
                    this.syncState();
                }
            },

            onPanelHiddenChange: function (panel, hidden) {
                if (!hidden) {
                    // eslint-disable-next-line vars-on-top
                    var panels = this.getAccordionPanels();

                    Ext.Array.remove(panels.$expanded, panel);

                    if (panels.$expanded.length) {
                        this.collapsePanelNoAnim(panel, true);
                    }
                }
            },

            onPanelHeaderClick: function (event) {
                var cmp = Ext.fly(event.delegatedTarget).component.ownerCmp;

                if (cmp.getCollapsed()) {
                    cmp.expand();
                } else {
                    cmp.collapse();
                }
            },

<span id='SU-panel-Accordion-method-collapsePanelNoAnim'>            /**
</span>             *
             * @param {Ext.panel.Panel} panel
             * @param {Boolean} collapsed
             * @private
             */
            collapsePanelNoAnim: function (panel, collapsed) {
                var ev = &#39;before&#39; + (collapsed ? &#39;collapse&#39; : &#39;expand&#39;);

                panel.suspendEvent(ev);

                if (panel.getCollapsible().unanimated) {
                    panel.getCollapsible().unanimated(function (collapser) {
                        collapser.setCollapsed(collapsed);
                    });
                } else {
                    console.log(&#39;collapsePanelNoAnim&#39;, panel.$className);
                    panel.setCollapsed(collapsed);
                }

                panel.resumeEvent(ev);
            },

<span id='SU-panel-Accordion-method-doSyncState'>            /**
</span>             *
             * @param {Object} info
             * @private
             */
            doSyncState: function (info) {
                var me = this,
                    panels = me.query(me.accordionSelector),
                    expanded = me.query(me.accordionSelector + &#39;[collapsed=false]&#39;),
                    item;

                if (!expanded.length &amp;&amp; me.getCollapseByDefault()) {
                    item = panels.pop();

                    if (item) {
                        me.collapsePanelNoAnim(item, false);
                    }
                } else {
                    // оставим пока как есть
                }
            },

<span id='SU-panel-Accordion-method-syncStateNow'>            /**
</span>             *
             * @param {Object} info
             * @private
             */
            syncStateNow: function (info) {
                this.cancelSyncState();
                this.doSyncState(info);
            }
        }
    };
});
</pre>
</body>
</html>
