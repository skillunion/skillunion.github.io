<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-chart-axis-Axis'>/**
</span> * @class Ext.chart.axis.Axis
 *
 * Defines axis for charts.
 *
 * Using the current model, the type of axis can be easily extended. By default, Sencha Charts provide three different
 * types of axis:
 *
 *  * **numeric** - the data attached to this axis is numeric and continuous.
 *  * **time** - the data attached to this axis is (or gets converted into) a date/time value; it is continuous.
 *  * **category** - the data attached to this axis belongs to a finite set. The data points are evenly placed along the axis.
 *
 * The behavior of an axis can be easily changed by setting different types of axis layout and axis segmenter to the axis.
 *
 * Axis layout defines how the data points are placed. Using continuous layout, the data points will be distributed by
 * the numeric value. Using discrete layout the data points will be spaced evenly. Furthermore, if you want to combine
 * the data points with the duplicate values in a discrete layout, you should use combineDuplicate layout.
 *
 * Segmenter defines the way to segment data range. For example, if you have a Date-type data range from Jan 1, 1997 to
 * Jan 1, 2017, the segmenter will segement the data range into years, months or days based on the current zooming
 * level.
 *
 * It is possible to write custom axis layouts and segmenters to extends this behavior by simply implementing interfaces
 * {@link Ext.chart.axis.layout.Layout} and {@link Ext.chart.axis.segmenter.Segmenter}.
 *
 * Here&#39;s an example for the axes part of a chart definition:
 * An example of axis for a series (in this case for an area chart that has multiple layers of yFields) could be:
 *
 *     axes: [{
 *         type: &#39;numeric&#39;,
 *         position: &#39;left&#39;,
 *         title: &#39;Number of Hits&#39;,
 *         grid: {
 *             odd: {
 *                 opacity: 1,
 *                 fill: &#39;#ddd&#39;,
 *                 stroke: &#39;#bbb&#39;,
 *                 lineWidth: 1
 *             }
 *         },
 *         minimum: 0
 *     }, {
 *         type: &#39;category&#39;,
 *         position: &#39;bottom&#39;,
 *         title: &#39;Month of the Year&#39;,
 *         grid: true,
 *         label: {
 *             rotate: {
 *                 degrees: 315
 *             }
 *         }
 *     }]
 *
 * In this case we use a `numeric` axis for displaying the values of the Area series and a `category` axis for displaying the names of
 * the store elements. The numeric axis is placed on the left of the screen, while the category axis is placed at the bottom of the chart.
 * Both the category and numeric axes have `grid` set, which means that horizontal and vertical lines will cover the chart background. In the
 * category axis the labels will be rotated so they can fit the space better.
 */
Ext.define(&#39;Ext.chart.axis.Axis&#39;, {
    xtype: &#39;axis&#39;,

    mixins: {
        observable: &#39;Ext.mixin.Observable&#39;
    },

    requires: [
        &#39;Ext.chart.axis.sprite.Axis&#39;,
        &#39;Ext.chart.axis.segmenter.*&#39;,
        &#39;Ext.chart.axis.layout.*&#39;,
        &#39;Ext.chart.Util&#39;
    ],

<span id='Ext-chart-axis-Axis-property-isAxis'>    isAxis: true,
</span>
<span id='Ext-chart-axis-Axis-event-rangechange'>    /**
</span>     * @event rangechange
     * Fires when the {@link Ext.chart.axis.Axis#range range} of the axis  changes.
     * @param {Ext.chart.axis.Axis} axis
     * @param {Array} range
     * @param {Array} oldRange
     */

<span id='Ext-chart-axis-Axis-event-visiblerangechange'>    /**
</span>     * @event visiblerangechange
     * Fires when the {@link #visibleRange} of the axis changes.
     * @param {Ext.chart.axis.Axis} axis
     * @param {Array} visibleRange
     */

<span id='Ext-chart-axis-Axis-cfg-id'>    /**
</span>     * @cfg {String} id
     * The **unique** id of this axis instance.
     */

    config: {
<span id='Ext-chart-axis-Axis-cfg-position'>        /**
</span>         * @cfg {String} position
         * Where to set the axis. Available options are `left`, `bottom`, `right`, `top`, `radial` and `angular`.
         */
        position: &#39;bottom&#39;,

<span id='Ext-chart-axis-Axis-cfg-fields'>        /**
</span>         * @cfg {Array} fields
         * An array containing the names of the record fields which should be mapped along the axis.
         * This is optional if the binding between series and fields is clear.
         */
        fields: [],

<span id='Ext-chart-axis-Axis-cfg-label'>        /**
</span>         * @cfg {Object} label
         *
         * The label configuration object for the Axis. This object may include style attributes
         * like `spacing`, `padding`, `font` that receives a string or number and
         * returns a new string with the modified values.
         *
         * For more supported values, see the configurations for {@link Ext.chart.sprite.Label}.
         */
        label: undefined,

<span id='Ext-chart-axis-Axis-cfg-grid'>        /**
</span>         * @cfg {Object} grid
         * The grid configuration object for the Axis style. Can contain `stroke` or `fill` attributes.
         * Also may contain an `odd` or `even` property in which you only style things on odd or even rows.
         * For example:
         *
         *
         *     grid {
         *         odd: {
         *             stroke: &#39;#555&#39;
         *         },
         *         even: {
         *             stroke: &#39;#ccc&#39;
         *         }
         *     }
         */
        grid: false,

<span id='Ext-chart-axis-Axis-cfg-limits'>        /**
</span>         * @cfg {Array|Object} limits
         * The limit lines configuration for the axis.
         * For example:
         *
         *     limits: [{
         *         value: 50,
         *         line: {
         *             strokeStyle: &#39;red&#39;,
         *             lineDash: [6, 3],
         *             title: {
         *                 text: &#39;Monthly minimum&#39;,
         *                 fontSize: 14
         *             }
         *         }
         *     }]
         */
        limits: null,

<span id='Ext-chart-axis-Axis-cfg-renderer'>        /**
</span>         * @cfg {Function} renderer Allows to change the text shown next to the tick.
         * @param {Ext.chart.axis.Axis} axis The axis.
         * @param {String/Number} label The label.
         * @param {Object} layoutContext The object that holds calculated positions
         * of axis&#39; ticks based on current layout, segmenter, axis length and configuration.
         * @param {String/Number/null} lastLabel The last label (if any).
         * @return {String} The label to display.
         * @controllable
         */
        renderer: null,

<span id='Ext-chart-axis-Axis-cfg-chart'>        /**
</span>         * @protected
         * @cfg {Ext.chart.AbstractChart} chart The Chart that the Axis is bound.
         */
        chart: null,

<span id='Ext-chart-axis-Axis-cfg-style'>        /**
</span>         * @cfg {Object} style
         * The style for the axis line and ticks.
         * Refer to the {@link Ext.chart.axis.sprite.Axis}
         */
        style: null,

<span id='Ext-chart-axis-Axis-cfg-margin'>        /**
</span>         * @cfg {Number} margin
         * The margin of the axis. Used to control the spacing between axes in charts with multiple axes.
         * Unlike CSS where the margin is added on all 4 sides of an element, the `margin` is the total space
         * that is added horizontally for a vertical axis, vertically for a horizontal axis,
         * and radially for an angular axis.
         */
        margin: 0,

<span id='Ext-chart-axis-Axis-cfg-titleMargin'>        /**
</span>         * @cfg {Number} [titleMargin=4]
         * The margin around the axis title. Unlike CSS where the margin is added on all 4
         * sides of an element, the `titleMargin` is the total space that is added horizontally
         * for a vertical title and vertically for an horizontal title, with half the `titleMargin`
         * being added on either side.
         */
        titleMargin: 4,

<span id='Ext-chart-axis-Axis-cfg-background'>        /**
</span>         * @cfg {Object} background
         * The background config for the axis surface.
         */
        background: null,

<span id='Ext-chart-axis-Axis-cfg-minimum'>        /**
</span>         * @cfg {Number} minimum
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        minimum: NaN,

<span id='Ext-chart-axis-Axis-cfg-maximum'>        /**
</span>         * @cfg {Number} maximum
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically.
         */
        maximum: NaN,

<span id='Ext-chart-axis-Axis-cfg-reconcileRange'>        /**
</span>         * @cfg {Boolean} reconcileRange
         * If &#39;true&#39; the range of the axis will be a union of ranges
         * of all the axes with the same direction. Defaults to &#39;false&#39;.
         */
        reconcileRange: false,

<span id='Ext-chart-axis-Axis-cfg-minZoom'>        /**
</span>         * @cfg {Number} minZoom
         * The minimum zooming level for axis.
         */
        minZoom: 1,

<span id='Ext-chart-axis-Axis-cfg-maxZoom'>        /**
</span>         * @cfg {Number} maxZoom
         * The maximum zooming level for axis.
         */
        maxZoom: 10000,

<span id='Ext-chart-axis-Axis-cfg-layout'>        /**
</span>         * @cfg {Object|Ext.chart.axis.layout.Layout} layout
         * The axis layout config. See {@link Ext.chart.axis.layout.Layout}
         */
        layout: &#39;continuous&#39;,

<span id='Ext-chart-axis-Axis-cfg-segmenter'>        /**
</span>         * @cfg {Object|Ext.chart.axis.segmenter.Segmenter} segmenter
         * The segmenter config. See {@link Ext.chart.axis.segmenter.Segmenter}
         */
        segmenter: &#39;numeric&#39;,

<span id='Ext-chart-axis-Axis-cfg-hidden'>        /**
</span>         * @cfg {Boolean} hidden
         * Indicate whether to hide the axis.
         * If the axis is hidden, one of the axis line, ticks, labels or the title will be shown and
         * no margin will be taken.
         * The coordination mechanism works fine no matter if the axis is hidden.
         */
        hidden: false,

<span id='Ext-chart-axis-Axis-cfg-majorTickSteps'>        /**
</span>         * @cfg {Number} [majorTickSteps=0]
         * Forces the number of major ticks to the specified value.
         * Both {@link #minimum} and {@link #maximum} should be specified.
         */
        majorTickSteps: 0,

<span id='Ext-chart-axis-Axis-cfg-minorTickSteps'>        /**
</span>         * @cfg {Number} [minorTickSteps=0]
         * The number of small ticks between two major ticks.
         */
        minorTickSteps: 0,

<span id='Ext-chart-axis-Axis-cfg-adjustByMajorUnit'>        /**
</span>         * @cfg {Boolean} adjustByMajorUnit
         * Whether to make the auto-calculated minimum and maximum of the axis
         * a multiple of the interval between the major ticks of the axis.
         * If {@link #majorTickSteps}, {@link #minimum} or {@link #maximum}
         * configs have been set, this config will be ignored.
         * Defaults to &#39;true&#39;.
         */
        adjustByMajorUnit: true,

<span id='Ext-chart-axis-Axis-cfg-title'>        /**
</span>         * @cfg {String|Object} title
         * The title for the Axis.
         * If given a String, the &#39;text&#39; attribute of the title sprite will be set,
         * otherwise the style will be set.
         */
        title: null,

<span id='Ext-chart-axis-Axis-cfg-expandRangeBy'>        /**
</span>         * @private
         * @cfg {Number} [expandRangeBy=0]
         */
        expandRangeBy: 0,

<span id='Ext-chart-axis-Axis-cfg-length'>        /**
</span>         * @private
         * @cfg {Number} length
         * Length of the axis position. Equals to the size of inner rect on the docking side of this axis.
         * WARNING: Meant to be set automatically by chart. Do not set it manually.
         */
        length: 0,

<span id='Ext-chart-axis-Axis-cfg-center'>        /**
</span>         * @private
         * @cfg {Array} center
         * Center of the polar axis.
         * WARNING: Meant to be set automatically by chart. Do not set it manually.
         */
        center: null,

<span id='Ext-chart-axis-Axis-cfg-radius'>        /**
</span>         * @private
         * @cfg {Number} radius
         * Radius of the polar axis.
         * WARNING: Meant to be set automatically by chart. Do not set it manually.
         */
        radius: null,

<span id='Ext-chart-axis-Axis-cfg-totalAngle'>        /**
</span>         * @private
         */
        totalAngle: Math.PI,

<span id='Ext-chart-axis-Axis-cfg-rotation'>        /**
</span>         * @private
         * @cfg {Number} rotation
         * Rotation of the polar axis in radians.
         * WARNING: Meant to be set automatically by chart. Do not set it manually.
         */
        rotation: null,

<span id='Ext-chart-axis-Axis-cfg-visibleRange'>        /**
</span>         * @cfg {Array} visibleRange
         * Specify the proportion of the axis to be rendered. The series bound to
         * this axis will be synchronized and transformed accordingly.
         */
        visibleRange: [0, 1],

<span id='Ext-chart-axis-Axis-cfg-needHighPrecision'>        /**
</span>         * @cfg {Boolean} needHighPrecision
         * Indicates that the axis needs high precision surface implementation.
         * See {@link Ext.draw.engine.Canvas#highPrecision}
         */
        needHighPrecision: false,

<span id='Ext-chart-axis-Axis-cfg-linkedTo'>        /**
</span>         * @cfg {Ext.chart.axis.Axis|String|Number} linkedTo
         * Axis (itself, its ID or index) that this axis is linked to.
         * When an axis is linked to a master axis, it will use the same data as the master axis.
         * It can be used to show additional info, or to ease reading the chart by duplicating the scales.
         */
        linkedTo: null,

<span id='Ext-chart-axis-Axis-cfg-floating'>        /**
</span>         * @cfg {Number|Object}
         * If `floating` is a number, then it&#39;s a percentage displacement of the axis from its initial {@link #position}
         * in the direction opposite to the axis&#39; direction. For instance, &#39;{position:&quot;left&quot;, floating:75}&#39; displays a vertical 
         * axis at 3/4 of the chart, starting from the left. It is equivalent to &#39;{position:&quot;right&quot;, floating:25}&#39;.
         * If `floating` is an object, then `floating.value` is the position of this axis along another axis,
         * defined by `floating.alongAxis`, where `alongAxis` is an ID, an {@link Ext.chart.AbstractChart#axes} config index,
         * or the other axis itself. `alongAxis` must have an opposite {@link Ext.chart.axis.Axis#getAlignment alignment}.
         * For example:
         *
         *
         *      axes: [
         *          {
         *              title: &#39;Average Temperature (F)&#39;,
         *              type: &#39;numeric&#39;,
         *              position: &#39;left&#39;,
         *              id: &#39;temperature-vertical-axis&#39;,
         *              minimum: -30,
         *              maximum: 130
         *          },
         *          {
         *              title: &#39;Month (2013)&#39;,
         *              type: &#39;category&#39;,
         *              position: &#39;bottom&#39;,
         *              floating: {
         *                  value: 32,
         *                  alongAxis: &#39;temperature-vertical-axis&#39;
         *              }
         *          }
         *      ]
         */
        floating: null
    },

<span id='Ext-chart-axis-Axis-property-titleOffset'>    titleOffset: 0,
</span>
<span id='Ext-chart-axis-Axis-property-spriteAnimationCount'>    spriteAnimationCount: 0,
</span>
<span id='Ext-chart-axis-Axis-property-boundSeries'>    boundSeries: [],
</span>
<span id='Ext-chart-axis-Axis-property-sprites'>    sprites: null,
</span>
<span id='Ext-chart-axis-Axis-property-surface'>    surface: null,
</span>
<span id='Ext-chart-axis-Axis-property-range'>    /**
</span>     * @private
     * @property {Array} range
     * The full data range of the axis. Should not be set directly, Clear it to `null`
     * and use `getRange` to update.
     */
    range: null,

<span id='Ext-chart-axis-Axis-property-defaultRange'>    defaultRange: [0, 1],
</span><span id='Ext-chart-axis-Axis-property-rangePadding'>    rangePadding: 0.5,
</span>
<span id='Ext-chart-axis-Axis-property-xValues'>    xValues: [],
</span>
<span id='Ext-chart-axis-Axis-property-yValues'>    yValues: [],
</span>
<span id='Ext-chart-axis-Axis-property-masterAxis'>    masterAxis: null,
</span>
<span id='Ext-chart-axis-Axis-method-applyRotation'>    applyRotation: function (rotation) {
</span>        var twoPie = Math.PI * 2;
        return (rotation % twoPie + Math.PI) % twoPie - Math.PI;
    },

<span id='Ext-chart-axis-Axis-method-updateRotation'>    updateRotation: function (rotation) {
</span>        var sprites = this.getSprites(),
            position = this.getPosition();
        if (!this.getHidden() &amp;&amp; position === &#39;angular&#39; &amp;&amp; sprites[0]) {
            sprites[0].setAttributes({
                baseRotation: rotation
            });
        }
    },

<span id='Ext-chart-axis-Axis-method-applyTitle'>    applyTitle: function (title, oldTitle) {
</span>        var surface;

        if (Ext.isString(title)) {
            title = { text: title };
        }

        if (!oldTitle) {
            oldTitle = Ext.create(&#39;sprite.text&#39;, title);
            if ((surface = this.getSurface())) {
                surface.add(oldTitle);
            }
        } else {
            oldTitle.setAttributes(title);
        }
        return oldTitle;
    },

<span id='Ext-chart-axis-Axis-method-applyFloating'>    applyFloating: function (floating, oldFloating) {
</span>        if (floating === null) {
            floating = {
                value: null,
                alongAxis: null
            };
        } else if (Ext.isNumber(floating)) {
            floating = {
                value: floating,
                alongAxis: null
            };
        }
        if (Ext.isObject(floating)) {
            if (oldFloating &amp;&amp; oldFloating.alongAxis) {
                delete this.getChart().getAxis(oldFloating.alongAxis).floatingAxes[this.getId()];
            }
            return floating;
        }
        return oldFloating;
    },

<span id='Ext-chart-axis-Axis-method-constructor'>    constructor: function (config) {
</span>        var me = this,
            id;

        me.sprites = [];
        me.labels = [];
        // Maps IDs of the axes that float along this axis to their floating values.
        me.floatingAxes = {};

        config = config || {};
        if (config.position === &#39;angular&#39;) {
            config.style = config.style || {};
            config.style.estStepSize = 1;
        }

        if (&#39;id&#39; in config) {
            id = config.id;
        } else if (&#39;id&#39; in me.config) {
            id = me.config.id;
        } else {
            id = me.getId();
        }
        me.setId(id);

        me.mixins.observable.constructor.apply(me, arguments);
    },

<span id='Ext-chart-axis-Axis-method-getAlignment'>    /**
</span>     * @private
     * @return {String}
     */
    getAlignment: function () {
        switch (this.getPosition()) {
            case &#39;left&#39;:
            case &#39;right&#39;:
                return &#39;vertical&#39;;
            case &#39;top&#39;:
            case &#39;bottom&#39;:
                return &#39;horizontal&#39;;
            case &#39;radial&#39;:
                return &#39;radial&#39;;
            case &#39;angular&#39;:
                return &#39;angular&#39;;
        }
    },

<span id='Ext-chart-axis-Axis-method-getGridAlignment'>    /**
</span>     * @private
     * @return {String}
     */
    getGridAlignment: function () {
        switch (this.getPosition()) {
            case &#39;left&#39;:
            case &#39;right&#39;:
                return &#39;horizontal&#39;;
            case &#39;top&#39;:
            case &#39;bottom&#39;:
                return &#39;vertical&#39;;
            case &#39;radial&#39;:
                return &#39;circular&#39;;
            case &#39;angular&#39;:
                return &#39;radial&#39;;
        }
    },

<span id='Ext-chart-axis-Axis-method-getSurface'>    /**
</span>     * @private
     * Get the surface for drawing the series sprites
     */
    getSurface: function () {
        var me = this,
            chart = me.getChart();

        if (chart &amp;&amp; !me.surface) {
            var surface = me.surface = chart.getSurface(me.getId(), &#39;axis&#39;),
                gridSurface = me.gridSurface = chart.getSurface(&#39;main&#39;);

            gridSurface.waitFor(surface);
            me.getGrid();

            me.createLimits();
        }
        return me.surface;
    },

<span id='Ext-chart-axis-Axis-method-createLimits'>    createLimits: function () {
</span>        var me = this,
            chart = me.getChart(),
            axisSprite = me.getSprites()[0],
            gridAlignment = me.getGridAlignment(),
            limits;

        if (me.getLimits() &amp;&amp; gridAlignment) {
            gridAlignment = gridAlignment.replace(&#39;3d&#39;, &#39;&#39;);
            me.limits = limits = {
                surface: chart.getSurface(&#39;overlay&#39;),
                lines: new Ext.chart.Markers(),
                titles: new Ext.draw.sprite.Instancing()
            };
            limits.lines.setTemplate({xclass: &#39;grid.&#39; + gridAlignment});
            limits.lines.getTemplate().setAttributes({strokeStyle: &#39;black&#39;}, true);
            limits.surface.add(limits.lines);
            axisSprite.bindMarker(gridAlignment + &#39;-limit-lines&#39;, me.limits.lines);

            me.limitTitleTpl = new Ext.draw.sprite.Text();
            limits.titles.setTemplate(me.limitTitleTpl);
            limits.surface.add(limits.titles);
        }
    },

<span id='Ext-chart-axis-Axis-method-applyGrid'>    applyGrid: function (grid) {
</span>        // Returning an empty object here if grid was set to &#39;true&#39; so that
        // config merging in the theme works properly.
        if (grid === true) {
            return {};
        }
        return grid;
    },

<span id='Ext-chart-axis-Axis-method-updateGrid'>    updateGrid: function (grid) {
</span>        var me = this,
            chart = me.getChart();

        if (!chart) {
            me.on({
                chartattached: Ext.bind(me.updateGrid, me, [grid]),
                single: true
            });
            return;
        }

        var gridSurface = me.gridSurface,
            axisSprite = me.getSprites()[0],
            gridAlignment = me.getGridAlignment(),
            gridSprite;

        if (grid) {
            gridSprite = me.gridSpriteEven;
            if (!gridSprite) {
                gridSprite = me.gridSpriteEven = new Ext.chart.Markers();
                gridSprite.setTemplate({xclass: &#39;grid.&#39; + gridAlignment});
                gridSurface.add(gridSprite);
                axisSprite.bindMarker(gridAlignment + &#39;-even&#39;, gridSprite);
            }
            if (Ext.isObject(grid)) {
                gridSprite.getTemplate().setAttributes(grid);
                if (Ext.isObject(grid.even)) {
                    gridSprite.getTemplate().setAttributes(grid.even);
                }
            }

            gridSprite = me.gridSpriteOdd;
            if (!gridSprite) {
                gridSprite = me.gridSpriteOdd = new Ext.chart.Markers();
                gridSprite.setTemplate({xclass: &#39;grid.&#39; + gridAlignment});
                gridSurface.add(gridSprite);
                axisSprite.bindMarker(gridAlignment + &#39;-odd&#39;, gridSprite);
            }
            if (Ext.isObject(grid)) {
                gridSprite.getTemplate().setAttributes(grid);
                if (Ext.isObject(grid.odd)) {
                    gridSprite.getTemplate().setAttributes(grid.odd);
                }
            }
        }
    },
    
<span id='Ext-chart-axis-Axis-method-updateMinorTickSteps'>    updateMinorTickSteps: function (minorTickSteps) {
</span>        var me = this,
            sprites = me.getSprites(),
            axisSprite = sprites &amp;&amp; sprites[0],
            surface;

        if (axisSprite) {
            axisSprite.setAttributes({
                minorTicks: !!minorTickSteps
            });
            surface = me.getSurface();
            if (!me.isConfiguring &amp;&amp; surface) {
                surface.renderFrame();
            }
        }
    },

<span id='Ext-chart-axis-Axis-method-getCoordFor'>    /**
</span>     *
     * Mapping data value into coordinate.
     *
     * @param {*} value
     * @param {String} field
     * @param {Number} [idx]
     * @param {Ext.util.MixedCollection} [items]
     * @return {Number}
     */
    getCoordFor: function (value, field, idx, items) {
        return this.getLayout().getCoordFor(value, field, idx, items);
    },

<span id='Ext-chart-axis-Axis-method-applyPosition'>    applyPosition: function (pos) {
</span>        return pos.toLowerCase();
    },

<span id='Ext-chart-axis-Axis-method-applyLength'>    applyLength: function (length, oldLength) {
</span>        return length &gt; 0 ? length : oldLength;
    },

<span id='Ext-chart-axis-Axis-method-applyLabel'>    applyLabel: function (label, oldLabel) {
</span>        if (!oldLabel) {
            oldLabel = new Ext.draw.sprite.Text({});
        }
        if (label) {
            if (this.limitTitleTpl) {
                this.limitTitleTpl.setAttributes(label);
            }
            oldLabel.setAttributes(label);
        }

        return oldLabel;
    },

<span id='Ext-chart-axis-Axis-method-applyLayout'>    applyLayout: function (layout, oldLayout) {
</span>        layout = Ext.factory(layout, null, oldLayout, &#39;axisLayout&#39;);
        layout.setAxis(this);
        return layout;
    },

<span id='Ext-chart-axis-Axis-method-applySegmenter'>    applySegmenter: function (segmenter, oldSegmenter) {
</span>        segmenter = Ext.factory(segmenter, null, oldSegmenter, &#39;segmenter&#39;);
        segmenter.setAxis(this);
        return segmenter;
    },

<span id='Ext-chart-axis-Axis-method-updateMinimum'>    updateMinimum: function () {
</span>        this.range = null;
    },

<span id='Ext-chart-axis-Axis-method-updateMaximum'>    updateMaximum: function () {
</span>        this.range = null;
    },

<span id='Ext-chart-axis-Axis-method-hideLabels'>    hideLabels: function () {
</span>        this.getSprites()[0].setDirty(true);
        this.setLabel({hidden: true});
    },

<span id='Ext-chart-axis-Axis-method-showLabels'>    showLabels: function () {
</span>        this.getSprites()[0].setDirty(true);
        this.setLabel({hidden: false});
    },

<span id='Ext-chart-axis-Axis-method-renderFrame'>    /**
</span>     * Invokes renderFrame on this axis&#39;s surface(s)
     */
    renderFrame: function () {
        this.getSurface().renderFrame();
    },

<span id='Ext-chart-axis-Axis-method-updateChart'>    updateChart: function (newChart, oldChart) {
</span>        var me = this,
            surface;

        if (oldChart) {
            oldChart.unregister(me);
            oldChart.un(&#39;serieschange&#39;, me.onSeriesChange, me);
            me.linkAxis();
            me.fireEvent(&#39;chartdetached&#39;, oldChart, me);
        }
        if (newChart) {
            newChart.on(&#39;serieschange&#39;, me.onSeriesChange, me);
            me.surface = null;
            surface = me.getSurface();
            me.getLabel().setSurface(surface);
            surface.add(me.getSprites());
            surface.add(me.getTitle());
            newChart.register(me);
            me.fireEvent(&#39;chartattached&#39;, newChart, me);
        }
    },

<span id='Ext-chart-axis-Axis-method-applyBackground'>    applyBackground: function (background) {
</span>        var rect = Ext.ClassManager.getByAlias(&#39;sprite.rect&#39;);
        return rect.def.normalize(background);
    },

<span id='Ext-chart-axis-Axis-method-processData'>    /**
</span>     * @protected
     * Invoked when data has changed.
     */
    processData: function () {
        this.getLayout().processData();
        this.range = null;
    },

<span id='Ext-chart-axis-Axis-method-getDirection'>    getDirection: function () {
</span>        return this.getChart().getDirectionForAxis(this.getPosition());
    },

<span id='Ext-chart-axis-Axis-method-isSide'>    isSide: function () {
</span>        var position = this.getPosition();
        return position === &#39;left&#39; || position === &#39;right&#39;;
    },

<span id='Ext-chart-axis-Axis-method-applyFields'>    applyFields: function (fields) {
</span>        return Ext.Array.from(fields);
    },

<span id='Ext-chart-axis-Axis-method-applyVisibleRange'>    applyVisibleRange: function (visibleRange, oldVisibleRange) {
</span>        this.getChart();
        // If it is in reversed order swap them
        if (visibleRange[0] &gt; visibleRange[1]) {
            var temp = visibleRange[0];
            visibleRange[0] = visibleRange[1];
            visibleRange[0] = temp;
        }
        if (visibleRange[1] === visibleRange[0]) {
            visibleRange[1] += 1 / this.getMaxZoom();
        }
        if (visibleRange[1] &gt; visibleRange[0] + 1) {
            visibleRange[0] = 0;
            visibleRange[1] = 1;
        } else if (visibleRange[0] &lt; 0) {
            visibleRange[1] -= visibleRange[0];
            visibleRange[0] = 0;
        } else if (visibleRange[1] &gt; 1) {
            visibleRange[0] -= visibleRange[1] - 1;
            visibleRange[1] = 1;
        }

        if (oldVisibleRange &amp;&amp; visibleRange[0] === oldVisibleRange[0] &amp;&amp; visibleRange[1] === oldVisibleRange[1]) {
            return undefined;
        }

        return visibleRange;
    },

<span id='Ext-chart-axis-Axis-method-updateVisibleRange'>    updateVisibleRange: function (visibleRange) {
</span>        this.fireEvent(&#39;visiblerangechange&#39;, this, visibleRange);
    },

<span id='Ext-chart-axis-Axis-method-onSeriesChange'>    onSeriesChange: function (chart) {
</span>        var me = this,
            series = chart.getSeries(),
            boundSeries = [],
            linkedTo, masterAxis, getAxisMethod,
            i, ln;

        if (series) {
            getAxisMethod = &#39;get&#39; + me.getDirection() + &#39;Axis&#39;;
            for (i = 0, ln = series.length; i &lt; ln; i++) {
                if (this === series[i][getAxisMethod]()) {
                    boundSeries.push(series[i]);
                }
            }
        }

        me.boundSeries = boundSeries;

        linkedTo = me.getLinkedTo();
        masterAxis = !Ext.isEmpty(linkedTo) &amp;&amp; chart.getAxis(linkedTo);
        if (masterAxis) {
            me.linkAxis(masterAxis);
        } else {
            me.getLayout().processData();
        }
    },

<span id='Ext-chart-axis-Axis-method-linkAxis'>    linkAxis: function (masterAxis) {
</span>        var me = this;
        function link(action, slave, master) {
            master.getLayout()[action](&#39;datachange&#39;, &#39;onDataChange&#39;, slave);
            master[action](&#39;rangechange&#39;, &#39;onMasterAxisRangeChange&#39;, slave);
        }
        if (me.masterAxis) {
            if (!me.masterAxis.destroyed) {
                link(&#39;un&#39;, me, me.masterAxis);
            }
            
            me.masterAxis = null;
        }
        if (masterAxis) {
            if (masterAxis.type !== this.type) {
                Ext.Error.raise(&quot;Linked axes must be of the same type.&quot;);
            }
            link(&#39;on&#39;, me, masterAxis);
            me.onDataChange(masterAxis.getLayout().labels);
            me.onMasterAxisRangeChange(masterAxis, masterAxis.range);
            me.setStyle(Ext.apply({}, me.config.style, masterAxis.config.style));
            me.setTitle(Ext.apply({}, me.config.title, masterAxis.config.title));
            me.setLabel(Ext.apply({}, me.config.label, masterAxis.config.label));
            me.masterAxis = masterAxis;
        }
    },

<span id='Ext-chart-axis-Axis-method-onDataChange'>    onDataChange: function (data) {
</span>        this.getLayout().labels = data;
    },

<span id='Ext-chart-axis-Axis-method-onMasterAxisRangeChange'>    onMasterAxisRangeChange: function (masterAxis, range) {
</span>        this.range = range;
    },

<span id='Ext-chart-axis-Axis-method-applyRange'>    applyRange: function (newRange) {
</span>        if (!newRange) {
            return this.dataRange.slice(0);
        } else {
            return [
                newRange[0] === null ? this.dataRange[0] : newRange[0],
                newRange[1] === null ? this.dataRange[1] : newRange[1]
            ];
        }
    },

<span id='Ext-chart-axis-Axis-method-setBoundSeriesRange'>    /**
</span>     * @private
     */
    setBoundSeriesRange: function (range) {
        var boundSeries = this.boundSeries,
            style = {},
            series, i,
            sprites, j,
            ln;

        style[&#39;range&#39; + this.getDirection()] = range;

        for (i = 0, ln = boundSeries.length; i &lt; ln; i++) {
            series = boundSeries[i];
            if (series.getHidden() === true) {
                continue;
            }
            sprites = series.getSprites();
            for (j = 0; j &lt; sprites.length; j++) {
                sprites[j].setAttributes(style);
            }
        }
    },

<span id='Ext-chart-axis-Axis-method-getRange'>    /**
</span>     * Get the range derived from all the bound series.
     * The range value is cached and returned the next time this method is called.
     * Set `recalculate` to `true` to recalculate the range, if changes to the
     * chart, its components or data are expected to affect the range.
     * @param {Boolean} [recalculate]
     * @return {Number[]}
     */
    getRange: function (recalculate) {
        var me = this,
            range = recalculate ? null : me.range,
            oldRange = me.oldRange,
            minimum, maximum;

        if (!range) {
            if (me.masterAxis) {
                range = me.masterAxis.range;
            } else {
                minimum = me.getMinimum();
                maximum = me.getMaximum();

                if ( Ext.isNumber(minimum) &amp;&amp; Ext.isNumber(maximum) ) {
                    range = [minimum, maximum];
                } else {
                    range = me.calculateRange();
                }

                me.range = range;
            }
        }

        if ( range &amp;&amp; (!oldRange || range[0] !== oldRange[0] || range[1] !== oldRange[1]) ) {
            me.fireEvent(&#39;rangechange&#39;, me, range, oldRange);
            me.oldRange = range;
        }

        return range;
    },

<span id='Ext-chart-axis-Axis-method-isSingleDataPoint'>    isSingleDataPoint: function (range) {
</span>        return (range[0] + this.rangePadding) === 0 &amp;&amp; (range[1] - this.rangePadding) === 0;
    },

<span id='Ext-chart-axis-Axis-method-calculateRange'>    calculateRange: function () {
</span>        var me = this,
            boundSeries = me.boundSeries,
            layout = me.getLayout(),
            segmenter = me.getSegmenter(),
            minimum = me.getMinimum(),
            maximum = me.getMaximum(),
            visibleRange = me.getVisibleRange(),
            getRangeMethod = &#39;get&#39; + me.getDirection() + &#39;Range&#39;,
            expandRangeBy = me.getExpandRangeBy(),
            context, attr, majorTicks,
            series, i, ln, seriesRange,
            range = [NaN, NaN];

        // For each series bound to this axis, ask the series for its min/max values
        // and use them to find the overall min/max.
        for (i = 0, ln = boundSeries.length; i &lt; ln; i++) {
            series = boundSeries[i];
            if (series.getHidden() === true) {
                continue;
            }
            seriesRange = series[getRangeMethod]();
            if (seriesRange) {
                Ext.chart.Util.expandRange(range, seriesRange);
            }
        }

        range = Ext.chart.Util.validateRange(range, me.defaultRange, me.rangePadding);

        // The second condition is there to account for a special case where we only have
        // a single data point, so the effective range of coordinated data is 0 (whatever
        // the actual value of that single data point is, it will be assigned an index of
        // zero, as the first and only data point). Since zero range is invalid, the
        // validateRange function above will expand the range by the value of the rangePadding,
        // which makes further expansion by the value of expandRangeBy unnecessary.
        if (expandRangeBy &amp;&amp; (!me.isSingleDataPoint(range))) {
            range[0] -= expandRangeBy;
            range[1] += expandRangeBy;
        }

        if (isFinite(minimum)) {
            range[0] = minimum;
        }
        if (isFinite(maximum)) {
            range[1] = maximum;
        }

        // When series `fullStack` config is used, the values may add up to
        // slightly more than the value of the `fullStackTotal` config
        // because of a precision error.
        range[0] = Ext.Number.correctFloat(range[0]);
        range[1] = Ext.Number.correctFloat(range[1]);

        me.range = range;

        // It&#39;s important to call &#39;me.reconcileRange&#39; after the &#39;range&#39;
        // has been assigned to avoid circular calls.
        if (me.getReconcileRange()) {
            me.reconcileRange();
        }
        // TODO: Find a better way to do this.
        // TODO: The original design didn&#39;t take into account that the range of an axis
        // TODO: will depend not just on the range of the data of the bound series in the
        // TODO: direction of the axis, but also on the range of other axes with the
        // TODO: same direction and on the segmentation of the axis (interval between
        // TODO: major ticks).
        // TODO: While the fist omission was possible to retrofit rather gracefully
        // TODO: by adding the axis.reconcileRange method, the second one is harder to deal with.
        // TODO: The issue is that the resulting axis segmentation, which is a part of
        // TODO: the axis sprite layout has to be known before layout has begun.
        // TODO: Example for the logic below:
        // TODO: If we have a range of data of 0..34.5 the step will be 2 and we
        // TODO: will round up the max to 36 based on that step, but when the range is 0..36,
        // TODO: the step becomes 5, so we have to reconcile the range once again where max
        // TODO: becomes 40.
        if (range[0] !== range[1] &amp;&amp; me.getAdjustByMajorUnit() &amp;&amp; segmenter.adjustByMajorUnit &amp;&amp; !me.getMajorTickSteps()) {
            attr = Ext.Object.chain(me.getSprites()[0].attr);
            attr.min = range[0];
            attr.max = range[1];
            attr.visibleMin = visibleRange[0];
            attr.visibleMax = visibleRange[1];
            context = {
                attr: attr,
                segmenter: segmenter
            };
            layout.calculateLayout(context);
            majorTicks = context.majorTicks;
            if (majorTicks) {
                segmenter.adjustByMajorUnit(majorTicks.step, majorTicks.unit.scale, range);

                attr.min = range[0];
                attr.max = range[1];
                context.majorTicks = null;
                layout.calculateLayout(context);
                majorTicks = context.majorTicks;
                segmenter.adjustByMajorUnit(majorTicks.step, majorTicks.unit.scale, range);
            } else if (!me.hasClearRangePending) {
                // Axis hasn&#39;t been rendered yet.
                me.hasClearRangePending = true;
                me.getChart().on(&#39;layout&#39;, &#39;clearRange&#39;, me);
            }
        }

        return range;
    },

<span id='Ext-chart-axis-Axis-method-clearRange'>    /**
</span>     * @private
     */
    clearRange: function () {
        this.hasClearRangePending = null;
        this.range = null;
    },

<span id='Ext-chart-axis-Axis-method-reconcileRange'>    /**
</span>     * Expands the range of the axis
     * based on the range of other axes with the same direction (if any).
     */
    reconcileRange: function () {
        var me = this,
            axes = me.getChart().getAxes(),
            direction = me.getDirection(),
            i, ln, axis, range;

        if (!axes) {
            return;
        }
        for (i = 0, ln = axes.length; i &lt; ln; i++) {
            axis = axes[i];
            range = axis.getRange();
            if (axis === me || axis.getDirection() !== direction || !range || !axis.getReconcileRange()) {
                continue;
            }
            if (range[0] &lt; me.range[0]) {
                me.range[0] = range[0];
            }
            if (range[1] &gt; me.range[1]) {
                me.range[1] = range[1];
            }
        }
    },

<span id='Ext-chart-axis-Axis-method-applyStyle'>    applyStyle: function (style, oldStyle) {
</span>        var cls = Ext.ClassManager.getByAlias(&#39;sprite.&#39; + this.seriesType);
        if (cls &amp;&amp; cls.def) {
            style = cls.def.normalize(style);
        }
        oldStyle = Ext.apply(oldStyle || {}, style);
        return oldStyle;
    },

<span id='Ext-chart-axis-Axis-property-themeOnlyIfConfigured'>    themeOnlyIfConfigured: {
</span>        grid: true
    },

<span id='Ext-chart-axis-Axis-method-updateTheme'>    updateTheme: function (theme) {
</span>        var me = this,
            axisTheme = theme.getAxis(),
            position = me.getPosition(),
            initialConfig = me.getInitialConfig(),
            defaultConfig = me.defaultConfig,
            configs = me.self.getConfigurator().configs,
            genericAxisTheme = axisTheme.defaults,
            specificAxisTheme = axisTheme[position],
            themeOnlyIfConfigured = me.themeOnlyIfConfigured,
            key, value, isObjValue, isUnusedConfig, initialValue, cfg;

        axisTheme = Ext.merge({}, genericAxisTheme, specificAxisTheme);
        for (key in axisTheme) {
            value = axisTheme[key];
            cfg = configs[key];
            if (value !== null &amp;&amp; value !== undefined &amp;&amp; cfg) {
                initialValue = initialConfig[key];
                isObjValue = Ext.isObject(value);
                isUnusedConfig = initialValue === defaultConfig[key];
                if (isObjValue) {
                    if (isUnusedConfig &amp;&amp; themeOnlyIfConfigured[key]) {
                        continue;
                    }
                    value = Ext.merge({}, value, initialValue);
                }
                if (isUnusedConfig || isObjValue) {
                    me[cfg.names.set](value);
                }
            }
        }
    },

<span id='Ext-chart-axis-Axis-method-updateCenter'>    updateCenter: function (center) {
</span>        var me = this,
            sprites = me.getSprites(),
            axisSprite = sprites[0],
            centerX = center[0],
            centerY = center[1];

        if (axisSprite) {
            axisSprite.setAttributes({
                centerX: centerX,
                centerY: centerY
            });
        }
        if (me.gridSpriteEven) {
            me.gridSpriteEven.getTemplate().setAttributes({
                translationX: centerX,
                translationY: centerY,
                rotationCenterX: centerX,
                rotationCenterY: centerY
            });
        }
        if (me.gridSpriteOdd) {
            me.gridSpriteOdd.getTemplate().setAttributes({
                translationX: centerX,
                translationY: centerY,
                rotationCenterX: centerX,
                rotationCenterY: centerY
            });
        }
    },

<span id='Ext-chart-axis-Axis-method-getSprites'>    getSprites: function () {
</span>        if (!this.getChart()) {
            return;
        }
        var me = this,
            range = me.getRange(),
            position = me.getPosition(),
            chart = me.getChart(),
            animation = chart.getAnimation(),
            length = me.getLength(),
            axisClass = me.superclass,
            mainSprite, style,
            animationModifier;

        // If animation is false, then stop animation.
        if (animation === false) {
            animation = {
                duration: 0
            };
        }

        style = Ext.applyIf({
            position: position,
            axis: me,
            length: length,
            grid: me.getGrid(),
            hidden: me.getHidden(),
            titleOffset: me.titleOffset,
            layout: me.getLayout(),
            segmenter: me.getSegmenter(),
            totalAngle: me.getTotalAngle(),
            label: me.getLabel()
        }, me.getStyle());

        if (range) {
            style.min = range[0];
            style.max = range[1];
        }

        // If the sprites are not created.
        if (!me.sprites.length) {
            while (!axisClass.xtype) {
                axisClass = axisClass.superclass;
            }
            mainSprite = Ext.create(&#39;sprite.&#39; + axisClass.xtype, style);
            animationModifier = mainSprite.getAnimation();
            animationModifier.setCustomDurations({
                baseRotation: 0
            });
            animationModifier.on(&#39;animationstart&#39;, &#39;onAnimationStart&#39;, me);
            animationModifier.on(&#39;animationend&#39;, &#39;onAnimationEnd&#39;, me);
            mainSprite.setLayout(me.getLayout());
            mainSprite.setSegmenter(me.getSegmenter());
            mainSprite.setLabel(me.getLabel());
            me.sprites.push(mainSprite);
            me.updateTitleSprite();
        } else {
            mainSprite = me.sprites[0];
            mainSprite.setAnimation(animation);
            mainSprite.setAttributes(style);
        }

        if (me.getRenderer()) {
            mainSprite.setRenderer(me.getRenderer());
        }

        return me.sprites;
    },

<span id='Ext-chart-axis-Axis-method-performLayout'>    /**
</span>     * @private
     */
    performLayout: function () {
        if (this.isConfiguring) {
            return;
        }
        var me = this,
            sprites = me.getSprites(),
            surface = me.getSurface(),
            chart = me.getChart(),
            sprite = sprites &amp;&amp; sprites[0];

        if (chart &amp;&amp; surface &amp;&amp; sprite) {
            sprite.callUpdater(null, &#39;layout&#39;); // recalculate axis ticks
            chart.scheduleLayout();
        }
    },

<span id='Ext-chart-axis-Axis-method-updateTitleSprite'>    updateTitleSprite: function () {
</span>        var me = this,
            length = me.getLength();

        if ( !me.sprites[0] || !Ext.isNumber(length) ) {
            return;
        }

        var thickness = this.sprites[0].thickness,
            surface = me.getSurface(),
            title = me.getTitle(),
            position = me.getPosition(),
            margin = me.getMargin(),
            titleMargin = me.getTitleMargin(),
            anchor = surface.roundPixel(length / 2);

        if (title) {
            switch (position) {
                case &#39;top&#39;:
                    title.setAttributes({
                        x: anchor,
                        y: margin + titleMargin / 2,
                        textBaseline: &#39;top&#39;,
                        textAlign: &#39;center&#39;
                    }, true);
                    title.applyTransformations();
                    me.titleOffset = title.getBBox().height + titleMargin;
                    break;
                case &#39;bottom&#39;:
                    title.setAttributes({
                        x: anchor,
                        y: thickness + titleMargin / 2,
                        textBaseline: &#39;top&#39;,
                        textAlign: &#39;center&#39;
                    }, true);
                    title.applyTransformations();
                    me.titleOffset = title.getBBox().height + titleMargin;
                    break;
                case &#39;left&#39;:
                    title.setAttributes({
                        x: margin + titleMargin / 2,
                        y: anchor,
                        textBaseline: &#39;top&#39;,
                        textAlign: &#39;center&#39;,
                        rotationCenterX: margin + titleMargin / 2,
                        rotationCenterY: anchor,
                        rotationRads: -Math.PI / 2
                    }, true);
                    title.applyTransformations();
                    me.titleOffset = title.getBBox().width + titleMargin;
                    break;
                case &#39;right&#39;:
                    title.setAttributes({
                        x: thickness - margin + titleMargin / 2,
                        y: anchor,
                        textBaseline: &#39;bottom&#39;,
                        textAlign: &#39;center&#39;,
                        rotationCenterX: thickness + titleMargin / 2,
                        rotationCenterY: anchor,
                        rotationRads: Math.PI / 2
                    }, true);
                    title.applyTransformations();
                    me.titleOffset = title.getBBox().width + titleMargin;
                    break;
            }
        }
    },

<span id='Ext-chart-axis-Axis-method-onThicknessChanged'>    onThicknessChanged: function () {
</span>        this.getChart().onThicknessChanged();
    },

<span id='Ext-chart-axis-Axis-method-getThickness'>    getThickness: function () {
</span>        if (this.getHidden()) {
            return 0;
        }
        return (this.sprites[0] &amp;&amp; this.sprites[0].thickness || 1) + this.titleOffset + this.getMargin();
    },

<span id='Ext-chart-axis-Axis-method-onAnimationStart'>    onAnimationStart: function () {
</span>        this.spriteAnimationCount++;
        if (this.spriteAnimationCount === 1) {
            this.fireEvent(&#39;animationstart&#39;, this);
        }
    },

<span id='Ext-chart-axis-Axis-method-onAnimationEnd'>    onAnimationEnd: function () {
</span>        this.spriteAnimationCount--;
        if (this.spriteAnimationCount === 0) {
            this.fireEvent(&#39;animationend&#39;, this);
        }
    },

<span id='Ext-chart-axis-Axis-method-getItemId'>    // Methods used in ComponentQuery and controller
</span>    getItemId: function () {
        return this.getId();
    },

<span id='Ext-chart-axis-Axis-method-getAncestorIds'>    getAncestorIds: function () {
</span>        return [this.getChart().getId()];
    },

<span id='Ext-chart-axis-Axis-method-isXType'>    isXType: function (xtype) {
</span>        return xtype === &#39;axis&#39;;
    },

<span id='Ext-chart-axis-Axis-method-resolveListenerScope'>    // Override the Observable&#39;s method to redirect listener scope
</span>    // resolution to the chart.
    resolveListenerScope: function (defaultScope) {
        var me = this,
            namedScope = Ext._namedScopes[defaultScope],
            chart = me.getChart(),
            scope;

        if (!namedScope) {
            scope = chart ? chart.resolveListenerScope(defaultScope, false) : (defaultScope || me);
        } else if (namedScope.isThis) {
            scope = me;
        } else if (namedScope.isController) {
            scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
        } else if (namedScope.isSelf) {
            scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
            // Class body listener. No chart controller, nor chart container controller.
            if (scope === chart &amp;&amp; !chart.getInheritedConfig(&#39;defaultListenerScope&#39;)) {
                scope = me;
            }
        }

        return scope;
    },

<span id='Ext-chart-axis-Axis-method-destroy'>    destroy: function () {
</span>        var me = this;

        me.setChart(null);
        me.surface.destroy();
        me.surface = null;
        me.callParent();
    }
});

</pre>
</body>
</html>
